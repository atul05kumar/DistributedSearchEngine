Add all greater values to every node in a given BST - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph Add all greater values to every node in a given BST Given a Binary Search Tree (BST), modify it so that all greater values in the given BST are added to every node. For example, consider the following BST. 
              50
           /      \
         30        70
        /   \      /  \
      20    40    60   80 

The above tree should be modified to following 

              260
           /      \
         330        150
        /   \       /  \
      350   300    210   80 We strongly recommend you to minimize the browser and try this yourself first. A simple method for solving this is to find sum of all greater values for every node. This method would take O(n^2) time. We can do it using a single traversal. The idea is to use following BST property. If we do reverse Inorder traversal of BST, we get all nodes in decreasing order. We do reverse Inorder traversal and keep track of the sum of all nodes visited so far, we add this sum to every node. 
// C program to add all greater values in every node of BST
#include<stdio.h>
#include<stdlib.h>

struct node
{
    int data;
    struct node *left, *right;
};

// A utility function to create a new BST node
struct node *newNode(int item)
{
    struct node *temp =  (struct node *)malloc(sizeof(struct node));
    temp->data = item;
    temp->left = temp->right = NULL;
    return temp;
}

// Recursive function to add all greater values in every node
void modifyBSTUtil(struct node *root, int *sum)
{
    // Base Case
    if (root == NULL)  return;

    // Recur for right subtree
    modifyBSTUtil(root->right, sum);

    // Now *sum has sum of nodes in right subtree, add
    // root->data to sum and update root->data
    *sum = *sum + root->data;
    root->data = *sum;

    // Recur for left subtree
    modifyBSTUtil(root->left, sum);
}

// A wrapper over modifyBSTUtil()
void modifyBST(struct node *root)
{
    int sum = 0;
    modifyBSTUtil(root, &sum);
}

// A utility function to do inorder traversal of BST
void inorder(struct node *root)
{
    if (root != NULL)
    {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

/* A utility function to insert a new node with given data in BST */
struct node* insert(struct node* node, int data)
{
    /* If the tree is empty, return a new node */
    if (node == NULL) return newNode(data);

    /* Otherwise, recur down the tree */
    if (data <= node->data)
        node->left  = insert(node->left, data);
    else
        node->right = insert(node->right, data);

    /* return the (unchanged) node pointer */
    return node;
}

// Driver Program to test above functions
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 */
    struct node *root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);

    modifyBST(root);

    // print inoder tarversal of the modified BST
    inorder(root);

    return 0;
} Output 350 330 300 260 210 150 80 Time Complexity: O(n) where n is number of nodes in the given BST. As a side note, we can also use reverse Inorder traversal to find kth largest element in a BST. This article is contributed by Chandra Prakash. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.           Related Topics: Perfect Binary Tree Specific Level Order Traversal Print Nodes in Top View of Binary Tree K Dimensional Tree Convert a Binary Tree to Threaded binary tree Serialize and Deserialize an N-ary Tree Serialize and Deserialize a Binary Tree Print nodes between two given level numbers of a binary tree Find Height of Binary Tree represented by Parent array Tweet Writing code in comment? Please use ideone.com and share the link here. trojansmith How about this… public class Tree { int data; Tree left; Tree right; Tree(int data,Tree left,Tree right){ this.data = data; this.left = left; this.right = right; } public void inorder(Tree node){ if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } } class Tree { int data; Tree left; Tree right; Tree(int data,Tree left,Tree right){ this.data = data; this.left = left; this.right = right; } public void inorder(Tree node){ if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }int data; Tree left; Tree right; Tree(int data,Tree left,Tree right){ this.data = data; this.left = left; this.right = right; } public void inorder(Tree node){ if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }left; Tree right; Tree(int data,Tree left,Tree right){ this.data = data; this.left = left; this.right = right; } public void inorder(Tree node){ if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }right; Tree(int data,Tree left,Tree right){ this.data = data; this.left = left; this.right = right; } public void inorder(Tree node){ if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }int data,Tree left,Tree right){ this.data = data; this.left = left; this.right = right; } public void inorder(Tree node){ if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }this.data = data; this.left = left; this.right = right; } public void inorder(Tree node){ if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }this.left = left; this.right = right; } public void inorder(Tree node){ if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }this.right = right; } public void inorder(Tree node){ if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }public void inorder(Tree node){ if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }if(node.left!=null)inorder(node.left); System.out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }out.println(node.data); if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }if(node.right!=null)inorder(node.right); } public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }public int addSum(Tree node,int sum){ if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }if(node.right!=null)sum=addSum(node.right,sum); if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }if(node!=null){ node.data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }data+=sum; sum=node.data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }data; } if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }if(node.left!=null)sum=addSum(node.left,sum); return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }return sum; } public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }public static void main(String[] args){ Tree node40 = new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }new Tree(40,null,null); Tree node20 = new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }new Tree(20,null,null); Tree node30 = new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }new Tree(30,node20,node40); Tree node60 = new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }new Tree(60,null,null); Tree node80 = new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }new Tree(80,null,null); Tree node70 = new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }new Tree(70,node60,node80); Tree root = new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } }new Tree(50,node30,node70); root.addSum(root,0); root.inorder(root); } } Guest Wow Solution sriharsha please correct me if am wrong; in the order travesal place the data in an array and then sort in 0(nlogn) time then find all greater values to every node..which takes o(n)..total o(nlogn)+o(n)=o(nlogn) time Roxanne this is not efficient. Could be modified by- inorder traversal = O(n). Store inorder nodes in a orderedhashmap. Iterate over it and find sum of numbers greater than x eg(tree with 3 nodes 3, left2, right 5) OrderedHM( key-2 value- 10 (8 +2) key- 3 value – 8 (5+3) key 5 – value-5 (right most in inorder) ) -> O(n) Traverse tree again and find sum in this hashmap with corresponding key – O(n) Sayali Sorry for the last post.. I meant don’t need to pass sum as a pointer in modifyBSTUtil, we can return it also.. Sayali Don’t need to pass sum as a pointer in modifyBSTUtil pavansrinivas Code in JAVA using reverse In-Order Validate me void addAllgreatValuesBST(){ Stack s = new Stack(); Node temp = root; int sum = 0; while(true){ while(temp!=null){ s.push(temp); temp = temp.right; } if(s.isEmpty()){ break; } temp = s.pop(); sum = sum+temp.i; temp.i = sum; System.out.print(temp.i+" "); temp = temp.left; } } Venkatesh //using Inorder traversal Right-Root-Left T(n) : O(n) // typedef struct tree mytree static int sum=0; mytree* addAllGreater(mytree *root) { if(root) { if(root->right) addAllGreater(root->right); root->data+=sum; sum+=root->data; if(root->left) addAllGreater(root->left); } } hary This will give incorrect result. Correct me If I am wrong in understanding the code, sum is getting added twice (take a closer look) Venkatesh @hary : Yess , you are right sum is getting added twice Correct steps are : root->data+=sum; sum=root->data; here for each node first sum will be added to it & then resulted sum will be placed into sum. Please correct me, if i am wrong Guest // using Inorder traversal Right-Root-Left T(n) : O(n) // typedef struct tree mytree static int sum=0; mytree* addAllGreater(mytree *root) { if(root) { if(root->right) addAllGreater(root->right); root->data+=sum; sum+=root->data; if(root->left) addAllGreater(root->left); } } Venkatesh // using Inorder traversal T(n) : O(n) // typedef struct tree mytree static int sum=0; mytree* temp[n]; mytree* AddAllGreater(mytree *root,int n) { mytree *t=root; int i=1,l //step1 : 1st take inorder traversal of BST Inorder(root); //step2 : now add all greater values to every node while(idata += sum; i++; } } void Inorder(mytree *t) { static int l=0; if(t) { if(t->left) Inorder(t->left); temp[l++]=t; sum+=temp[l]->data; if(t->right) Inorder(t->right); } } Coder011 void rev_inorder(struct node *root,int *key) { if(root) { rev_inorder(root->right,key); int temp=(root->data); (root->data)+=(*key); (*key)+=temp; rev_inorder(root->left,key); } } Coder011 void rev_inorder(struct node *root,int *key) { if(root) { rev_inorder(root->right,key); int temp=(root->data); (root->data)+=(*key); (*key)+=temp; rev_inorder(root->left,key); } } Kuldeep Kumar int temp = 0; int addAll ( node *t ) { if ( t ){ addAll ( t->right ) ; temp += t->data ; t->data = temp ; addAll ( t->left ) ; } } Guest Can also be done like this…. int temp=0; int addAll ( node *t ){ if ( t ) { addAll ( t->right ) ; temp += t->data ; t->data = temp ; addAll ( t->left ) ; } } rahul @Geeksforgeeks. It is a duplicate post.Same has already been discussed at http://www.geeksforgeeks.org/convert-bst-to-a-binary-tree/ Rahul GeeksforGeeks rahul, thanks for pointing this out. We will take care of this going forward. Random Yep, pretty simple Depth first search but go to the right child first instead of left. Keeping track of the sum of your right nodes. dinesh.expertjobs We can do the same thing by traversing the tree in reverse-in-order and keep on passing the sum of the values greater than the current node. Initially we call the function with root, 0 as parameters. when we are calling the function on a left subtree, we add the current nodes updated value to it. int modifyBst(node *root, int psum){ if(root == NULL) return 0; int rs = modifyBst(root->right, psum); int data = root->data; root->data += rs+psum; int ls = modifyBst(root->left, root->data); return (rs+ls+data); } Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
