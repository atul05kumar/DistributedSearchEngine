Find the Increasing subsequence of length three with maximum product - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph Find the Increasing subsequence of length three with maximum product Given a sequence of non-negative integers, find the subsequence of length 3 having maximum product with the numbers of the subsequence being in ascending order. Examples:  
Input: 
arr[] = {6, 7, 8, 1, 2, 3, 9, 10} 
Output: 
8 9 10

Input: 
arr[] = {1, 5, 10, 8, 9}
Output: 5 8 9 Since we want to find the maximum product, we need to find following two things for every element in the given sequence: LSL: The largest smaller element on left of given element LGR: The largest greater element on right of given element. Once we find LSL and LGR for an element, we can find the product of element with its LSL and LGR (if they both exist). We calculate this product for every element and return maximum of all products. A simple method is to use nested loops. The outer loop traverses every element in sequence. Inside the outer loop, run two inner loops (one after other) to find LSL and LGR of current element. Time complexity of this method is O(n2). We can do this in O(nLogn) time. For simplicity, let us first create two arrays LSL[] and LGR[] of size n each where n is number of elements in input array arr[]. The main task is to fill two arrays LSL[] and LGR[]. Once we have these two arrays filled, all we need to find maximum product LSL[i]*arr[i]*LGR[i] where 0 < i < n-1 (Note that LSL[i] doesn't exist for i = 0 and LGR[i] doesn't exist for i = n-1). We can fill LSL[] in O(nLogn) time. The idea is to use a Balanced Binary Search Tree like AVL. We start with empty AVL tree, insert the leftmost element in it. Then we traverse the input array starting from the second element to second last element. For every element currently being traversed, we find the floor of it in AVL tree. If floor exists, we store the floor in LSL[], otherwise we store NIL. After storing the floor, we insert the current element in the AVL tree. We can fill LGR[] in O(n) time. The idea is similar to this post. We traverse from right side and keep track of the largest element. If the largest element is greater than current element, we store it in LGR[], otherwise we store NIL. Finally, we run a O(n) loop and return maximum of LSL[i]*arr[i]*LGR[i] Overall complexity of this approach is O(nLogn) + O(n) + O(n) which is O(nLogn). Auxiliary space required is O(n). Note that we can avoid space required for LSL, we can find and use LSL values in final loop. This article is contributed by Amit Jain. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.           Related Topics: K’th Smallest/Largest Element in Unsorted Array | Set 2 (Expected Linear Time) K’th Smallest/Largest Element in Unsorted Array | Set 1 Time complexity of insertion sort when there are O(n) inversions? How to check if two given sets are disjoint? Minimum Number of Platforms Required for a Railway/Bus Station Find the closest pair from two sorted arrays Print all elements in sorted order from row and column wise sorted matrix Length of the largest subarray with contiguous elements | Set 1 Tweet Writing code in comment? Please use ideone.com and share the link here. guest void max_mul(int arr[],int s) { int m1,m2,m3; int i; m1=m2=m3=0; for(i=0;im1) { if(m2 && arr[i]>m2) { if(m3 && arr[i]>m3) { m1=m2; m2=m3; m3=arr[i]; } else { if(!m3) m3=arr[i]; if(arr[i]<m3) m3=arr[i]; } } else { if(!m2) m2=arr[i]; } } else { if(!m1) m1=arr[i]; } } printf("%dt%dt%d",m1,m2,m3); } main() { //f_str(f,str); max_mul(arr,(sizeof(arr)/sizeof(arr[0]))); // printf("nn final string is:%snn",str); } guest void max_mul(int arr[],int s) { int m1,m2,m3; int i; m1=m2=m3=0; for(i=0;im1) { if(m2 && arr[i]>m2) { if(m3 && arr[i]>m3) { m1=m2; m2=m3; m3=arr[i]; } else { if(!m3) m3=arr[i]; if(arr[i]<m3) m3=arr[i]; } } else { if(!m2) m2=arr[i]; } } else { if(!m1) m1=arr[i]; } } printf("%dt%dt%d",m1,m2,m3); } main() { max_mul(arr,(sizeof(arr)/sizeof(arr[0]))); } pretentious.bastard C# code /*Find increasing subsequence of length 3 with max product*/ public static List SubsequenceWithMaxProduct(int[] arr, int seqSize) { /*the strategy would be to create another array that contains the largest number encountered to the left of curr element, * curr elem inclusive. Then select the seqSize largest numbers of this array.*/ int[] maxToLeftInc = new int[arr.Length]; int maxToLeft = arr[0]; maxToLeftInc[0] = maxToLeft; for (int i = 1; i maxToLeft) maxToLeft = arr[i]; maxToLeftInc[i] = maxToLeft; } List retArr = new List(); for (int i = maxToLeftInc.Length – 1; i >= 0 && seqSize>0; i–) { if (retArr.Count == 0 || maxToLeftInc[i] != retArr[retArr.Count – 1]) { retArr.Add(maxToLeftInc[i]); seqSize–; } } return retArr; } Meenal Can we sort the array in O(nlogn) and take product of last three elements? Ankit Chaudhary this is wrong approach : eg : 5 10 8 9 According to u : 5 8 9 10 ans= 8*9*10 = 720 but this is not increasing subsequence correct answer : 5*8*9 Meenal My bad.. Thanks for clarification Guest Is is wrong to sort the array in O(nlogn) and take product of last three elements sambhavsharma You need to return the subsequence: for sequence of numbers: 5 10 8 9 if you sort the array, you would get : 8 9 10 which is not a subsequence, if you get what I mean. instead 5 8 9 is the correct answer as it is clearly a subsequence. Roohi Syeda Can we use RMQ (Max) to find LSL, even this gives time complexity of O(nlogn) but the space complexity is also O(nlogn) not better than AVL Google My bad.. This doesn’t work.. Davis Sort the array in O(nlogn), or you can make a copy and sort. Pick the last/first 3 elements based on how the array is sorted. guest You should combine this with a reverse hashmap to check if the elements form an increasing subsequence. Ex: 6,7,8,10,9 correspond to indices 0,1,2,3,4 (Use hashmap(Java) or map(C++) to keep track of indices) Sorted array – 6,7,8,9,10 correspond to indices 0,1,2,4,3 Select last three element from the back and check if it is an increasing subsequence, if not go to the previous 3 elements and so on. 8,9,10 => 2,4,3 (non-increasing) 7,8,9 => 1,2,4 (increasing subsequence) – which is the answer. Ankit Chaudhary ur approach is wrong Aaquib Khwaja How is the approach wrong, can u please explain ? coderor int main() { int arr[] = {1, 5, 10, 8, 9}; node * root = createAVL(arr, 5); if there are more than 3 nodes cout << maxProduct(root); else cout <right); // Check if current node will be part of max prodcut group if ( count > 2) // It won’t be return maxProduct(root->right); else if ( count == 2)// It will be { if ( root->right->right != NULL) return root->data * root->right->data * root->right->right->data; else // Two elements will be from right subtree return root->data * root->right->data * maxNodeInLeftSutree(root->left); } else if ( count == 1) // need to take one element from the left subtree return root->data * root->right->right * maxNodeLeftSubtree(root->left); else { cout <right != NULL) root = root->right; return root->data; } int countNodes(node *root) { if ( root == NULL) return 0; else return count(root->left) + count(root->right) + 1; } Harendra Singh all the ones having solution of O(n) are wrong, Guantana Chikoslavia @GeeksForGeeks This can be achieved in O(n) with O(n) space. Maintain a stack in increasing order. {code} for(i=0; i a[i]) { stack.pop(); } stack.push(); //calculateproduct of last three elements in stack and comare it with maxSoFar } {code} siren09 This can be easily solved in O(n) time complexity and using O(n) auxiliary space. Harendra Singh can u tell us how? Aravindan B Hi why cant we fill LSL[] in the same way as LGL[]. Any logic behind using an AVL tree? I am trying to understand the logic used http://www.cyukang.com/ Yukang yes, I am also confusing about that, we can scan from left to right for fill the LSL http://www.cyukang.com/ Yukang Oh?no, we need to keep the result in order. Kaife Since we have to find number less then current number but greater among numbers before current number which is less then current Harendra Singh if you just keep track of the lowest number until current number (like we are doing in of LGL, keeping track of the largest number until current number) then we we cannot be sure that the number is largest among all the smaller number than current number. Lets take an example numbers 5 10 2 6 26 smaller no until current -1 5 5 2 2 now for 26 the smaller no we found is 2 but it is not the largest among [2,5,10,6] which all were smaller than 26 if we do this naively we have search all the way back from current no to find the largest number smaller than current no, that will take O(n) time so we use a self balancing tree. I hope its clear now. Chen Pang Instead of treating each element in the iteration as the middle element, why not treat it as the left element? For each element, the maximum product it can produce, is itself with two largest elements on its right in ascending order. We can find it by populating the following arrays: LGR: The largest greater element on right of given element. If there is no greater element on the right for element i, set LGR[i] = -1 SGR (second largest greater right): This is the largest greater element on the right of given element with LGR[i] != -1. If there is no such element, set SGR[i] = -1 Both LGR and SGR can be populated easily in O(n) time, thus making the overall algorithm O(n) For array {6, 7, 8, 1, 9, 2, 3, 10} LGR is { 10, 10, 10, 10, 10, 10, 10, -1 } SGR is { 9, 9, 9, 9, -1, 3, -1, -1} Then we can easily generate the result: (8, 9, 10) http://www.cyukang.com/ Yukang actually this is not the right solution, you have to give a sequence results, think about this test case: 1 5 10 8 9 LGR 10 10 9 9 -1 SGR 9 9 -1 -1 -1 you method give ans: 450 5 9 10 but the true ans is : 5 8 9 Chen Pang No, LGR for element 10 is -1, because 9 is smaller than 10. (The LGR array in the article is exactly the same, except null value is used instead of -1). Therefore, SGR for element 5 cannot use 10, and it cannot use 9 either. That is the condition I put in the algorithm. When populating SGR array, elements in LGR with value -1 should be simply ignored. The correct values in your case would be: 1 5 10 8 9 LGR is: [10, 10, -1, 9, -1] SGR is: [8, 8, -1, -1, -1] In fact in the implementation, you should store index instead of values: LGR is : [2, 2, -1, 4, -1] SGR is : [3, 3, -1, -1, -1] The triplets at i-th element is: i, SGR[i], LGR[SGR[i]]. Note, it is NOT i, SGR[i], LGR[i]. So you can get the correct sequence: i (1) => 5 SGR[i] (3) => 8 LGR[3] (4) => 9 rk Can u please tell the answer for this example : a = [10,20,1235,40,50]. I dont think this algo will work for this example Chen Pang Indeed, the algorithm is wrong Hariprasadmce I think your algo should work -1 10 20 20 40 1235 1235 -1 50 -1 – 10*20*1235 – 20 * 40 *50 – Answer is 10 * 20 * 1235 Chen Pang Instead of treating each element as the middle element, why not treat it as the left element? For each left element, the maximum product it produces is itself with the largest and the second largest elements on right. We can use two arrays to store largest and second largest elements on the right for each element. We can post both arrays in one pass from right to left. The overal complexity would become O(n) Sandeep Sharma Another possible solution for filling LSL[] though(O(nlogn)) is to construct segment tree in (nlogn) and running minimum element range queries for index 0 to n Harendra Singh I dont think that would work, becoz it will just give the min of the range but we require the largest of all the smaller no than current no Please reply if I am wrong. Govind Simply we can sort the array first in O(nlogn). Then start from Last element of array & go backward until you find 3 distinct element. O(nlogn)+o(n) Arrays.sort(int arr[]); int i=arr.length-1; int j=0; int product=1; while(j!=3){ if(i>0 && arr[i] > arr[i-1]) { Product=product*arr[i]; j++; } i–; } Harendra Singh sorry bro but that’s completely wrong lets take an eg 100 10 20 30 1 2 3 ans we 10*20*30 your approach => 1 2 3 10 20 30 100 => 100*30*20 see when you sort the list you loose the original order which is imp for this problem since the 3 numbers have to be in a order. hope that’s clear. Abhay pandey O(n) solution: #include void main() //main function begin { int arr[20]; //array maximum size int max=0,p,k=-1; //variable declaration int i,n; printf(“enter the range of array:”); scanf(“%d”,&n); //how much element you want to enter printf(“enter the element:”); for(i=0;i<n;i++) scanf("%d",&arr[i]); //element insertion for(i=0;imax) { max=p; //swapping the product by max variable k++; } } printf(“nthe maximum product is : %d”,max); //now printing the maxium product printf(“nthe sub array index is:”); for(i=k;i<=k+2;i++) printf("t%d",arr[i]); //printing the index value } Abhay pandey Neha Garg can we not fill lsl[] in 0[n] like lgr ???? Harendra Singh Nope if you just keep track of the lowest number until current number (like we are doing in of LGL, keeping track of the largest number until current number) then we we cannot be sure that the number is largest among all the smaller number than current number. Lets take an example numbers 5 10 2 6 26 smaller no until current -1 5 5 2 2 now for 26 the smaller no we found is 2 but it is not the largest among [2,5,10,6] which all were smaller than 26 if we do this naively we have search all the way back from current no to find the largest number smaller than current no, that will take O(n) time so we use a self balancing tree. I hope its clear now. dec C# static void CompareToMaxProduct(List win, ref int max, ref int[] curr) { if (win == null) throw new ArgumentNullException(); int currPr = 1; win.ForEach(item => { currPr *= item; }); if(currPr > max) { max = currPr; curr = win.ToArray(); } return; } ? ? static int[] FindMaxPr(int[] arr, int winSize) { if (arr == null || arr.Length < winSize) throw new ArgumentException(); int maxProduct = Int32.MinValue; int[] resArr = new int[winSize]; List currArr = new List(winSize); for (var idx = 0; idx <= arr.Length – winSize; ++idx) { currArr.Clear(); currArr.Add(arr[idx]); for (var cmpIdx = idx + 1; cmpIdx < arr.Length; ++cmpIdx) { if (currArr[currArr.Count – 1] < arr[cmpIdx]) { currArr.Add(arr[cmpIdx]); } if (currArr.Count == winSize) { CompareToMaxProduct(currArr, ref maxProduct, ref resArr); } } } return resArr; } tammana correct me if i m wrong.. it can be done in O(n) times. consider main(){ int a[]={15,8,12,9,65,88,96,6,84}; int b[3]={0,0,0}; int k=0;// maximum sub sequence of array of length 3 for(int i=0;i<a.length();i++) { if(b[2]3) { k=0; } } } }//b[k] will give the maximum sub sequence in increasing order,k can be replaced by n here.. Kai Luo What is the floor of an element Harendra Singh 100 50 170 25 60 120 200 10 30 55 65 118 125 180 210 floor if the right-most child of the left child ie largest element from left sub-tree floor of 100 is 65 floor of 50 is 30 floor of 170 is 125 floor of 120 is 118 Hope that’s clear now MS Floor and Inorder Predecessor are the same right Prashanth It’s not necessary that a[n-1] should be in the max prod. Also why are you taking the consecutive elements a[i-1]*a[i] ? Protocol if u r sorting, then u r not finding increasing subsequence Harendra Singh sorry bro but that’s completely wrong lets take an eg 100 10 20 30 1 2 3 ans we 10*20*30 your approach => 1 2 3 10 20 30 100 => this will give 20*30*100 see when you sort the list you loose the original order which is imp for this problem since the 3 numbers have to be in a order. hope that’s clear. kiruthika91 Algorithm : 1. Have one more array to store the position (say Position) 2. Sort both the arrays in the descending order with respect to the input array. 3. Take first three elements and check their corresponding position, – Check whether they are in descending order using the position array – If not in descending order continue with next 3 consecutive till the condition satisfies. Time Complexity – O(n logn) Ankit Chaudhary This is not correct solution. Eg : array = {10,20,12345,40,50} after sorting : {12345,50,40,20,10} position : {3,5,4,2,1} According to ur algo ans is : 50*40*20=40000 but correct ans is = 12345*20*10=2469000 IsAs Slightly different variant of above solution Compute LSL in O(nlogn) time, also store the indices of largest smaller element on left hand side – let’s call it as PrevLarger[] PrevLarger[i] stores the index of largest smaller element on left hand side Idea is to identify two largest smaller elements on left hand side for every element in given array First_Largest_smaller_element = LSL[i] Second_Largest_smaller_element = LSL[PrevLarger[i]] compute this value –> arr[i]*First_Largest_smaller_element*Second_Largest_smaller_element http://xoxo.gl Ronald I believe I have an O(n) solution which passes backwards through the array only once. array = [1, 5, 10, 8, 9] #working values: best subsequences found so far best1 = [-1] best2 = [-1,-1] best3 = [-1,-1,-1] #array product – finds the products of arrays length up to 3 def product(a): p = 1 for i in a: p = p * i return p #passes backwards through the array once, improving the best subsequences where possible while (len(array)>0): candidate = array.pop() #if candidate with length-1 makes better length-2, replace it if (candidate < best1[0]): cand2 = [candidate] + best1 if product(cand2) > product(best2): best2 = cand2 #if candidate with length-2 makes better length-3, replace it if (candidate < best2[0]): cand3 = [candidate] + best2 if product(cand3) > product(best3): #could speed up by storing the products best3 = cand3 #if candidate can improve length-3, do it if (candidate > best3[0]) and (candidate < best3[1]): best3[0] = candidate #if candidate can improve length-2, do it if (candidate > best2[0]) and (candidate < best2[1]): best2[0] = candidate #if candidate can improve length-1, do it if (candidate > best1[0]): best1[0] = candidate print best3 http://xoxo.gl Ronald ah no, I know now why this needs a small fix that would make it theoretically slower. e.g. [7,6,13,8,9]  
/* Paste your code here (You may delete these lines if not writing code) */
 ASMITA //Find the Increasing subsequence of length three with maximum product #include using namespace std; int main() { int arr[] = {1, 5, 10, 8, 9}; int len = sizeof(arr)/sizeof(int); int prod[10],res1[10],res2[10],prev_prod,c; int i,j; for(i=0;i<len;i++) prod[i]=1; for(i=2;i<len;i++) { prev_prod=0,c=0 ; for(j=0;j<i;j++) { if(arr[j]<arr[i]) { if(prev_prod<arr[j]) { if(c<2) { prev_prod=arr[j]; prod[i]=prod[i]*arr[j]; res1[i]=arr[i]; res2[i]=arr[j]; c++; } else { int res = prod[i]/(prev_prod); if(prod[i]<(prod[i]/res)*arr[j]) { res1[i]=prev_prod; prev_prod=arr[j]; prod[i]= prod[i]/res; prod[i]=prod[i]*arr[j]; res2[i]=arr[j]; } } } } } prod[i]=prod[i]*arr[i]; } int max=0; for(i=0;i<len;i++) { if(max<prod[i]) { max=prod[i]; j=i; } } cout<<"Max product:"<<max<<"\n"; cout<<"From:\t"<<arr[j]<<"\t"<<res1[j]<<"\t"<<res2[j]; return 0; } Hiren Pandya It is giving output 9 5 8… Which is possibly not correct… Hiren Pandya Sorry… Got some mistake… Your program is perfectly alright… Its perfectly correct… Sorry… sairam may be it is easy   /* Paste your code here (You may delete these lines if not writing code) */ [/#include #include #include int main() { int *a,b[6]={0}; int i,j=0,k,n,m,pro=0,flag=0,x=0,y=0,z=0,p=0,l=0,a1,b1,c1; printf(“enter no of ele in array”); scanf(“%d”,&n); a=(int *)malloc(sizeof(int)*n); for(i=0;i<n;i++) scanf("%d",&a[i]); for(i=0;ib[j]) { j++; b[j]=x; printf(“%d\n”,b[j]); } } if(j<=2) { printf("wrong input"); exit(0);} for(i=0;i<n-2;i++) { x=a[i]; for(k=i+1;kx){ y=a[k]; for(l=i+2;ly) { z=a[l]; p=x*y*z; if(p>pro) { a1=x; b1=y; c1=z; pro=p; } } } } }} printf(“pro is %d x %d y %d z %d”,pro,a1,b1,c1); getch(); return 0; } ] Novice I think if we sort the given array in ascending order and consider last 3 elements. Then product of these element must be highest always. Can someone explain me. Am i understanding it wrong? given e.g. Input: arr[] = {6, 7, 8, 1, 2, 3, 9, 10} Output: 8 9 10 = product( 720 ) Input: arr[] = {1, 5, 10, 8, 9} should be Output: 10, 8, 9 = product ( 720) yelnatz Read the title again. Prashanth suppose input = { 6, 7, 8, 1, 2, 3, 10, 9 } output should be 7*8*10 = 560. But if you sort you will get ans = 8*9*10 = 720 redredp Your 3rd method is cool, but you made a little mistake at the line : std::deque<int> Qi(k); When you do that, the constructor “explicit deque(size_type count );” is called and allocate k elements. Each element is either default-constructed (if your deque is templated on a class), or filled with uninitialized values (if your dequeue is templated on scalar types, like here). Use this and it will be good : std::deque<int> Qi; gaurav Why can’t we calculate LSL similar to LGL. That way complexity will be O(n). yelnatz Because if you’re only keeping track of the largest element to the left of i during the single iteration, we won’t know what to do if the largest element is bigger than the element at i. So we look at the next biggest element? What if its still bigger, etc. Now we’re back to the solution above. anoop for LSL we can strat from the left and have a sorted array and for element insert it in the approprite place using binary search.the element on the left of this elemnt is the LSL for that element AMIT You are suggesting something like binary insertion sort which will take o(n^2)..Correct me if I am wrong Harendra Singh correct but still will take O(logn) to insert in that sorted list MB  
/* Paste your code here (You may delete these lines if not writing code) */
This can be done in O(n), below is Java program for it.
We can easily add functionality to get indexes too. 
public class IncreasingSubSequenceOfThreeWithMaximumProduct {

    public static void main(String[] args) {
        int index=0;
        int count=1;

        int arr[] = {6, 7, 8, 1, 2, 3, 9, 10} ;
        int temp_product=-1;
        int product = -1;

        for (int i=0;i<arr.length-1;i++){
            while(i<arr.length-1 && arr[i]<=arr[i+1])
            {     count++;
                  i++;
            }if(count>2){
                temp_product = arr[i]*arr[i-1]*arr[i-2];
                count=1;
            }
            if(temp_product>product) product= temp_product;
        }
        System.out.println(product);

        }


}


 anoop you are multiplying consecutive elements which is not the case always  
/* Paste your code here (You may delete these lines if not writing code) */
 MB My bad! Thank you anoop! hxgxs1 what should be the output if input is like; a[] = {10,9,8,7,6,5,4,3,2,1} ?? akki This type of input should be treated as invalid input.. srb we can use this method with little modification… http://www.geeksforgeeks.org/find-a-sorted-subsequence-of-size-3-in-linear-time/ plz correct me if i am wrong… akki Still not possible in 0(n)..notice you have to find the greatest smallest…not only the smallest.. or if u think it is possible please elaborate your algo akki Another easier method so find LSL is so sort the given array and maintaining the index.(called struct sort) Traverse sorted array and say we are looking at number a[i] the greatest smaller than this will be a[i-1](in sorted array) now check the index of a[i] and a[i-1] if index of a[i-1] is less than index of a[i] then store a[i-1] in LCL otherwise store nil. Abhi16 Please explain how is the time complexity of LSL O(nlogn). Thank you. yelnatz constructing an AVL tree is nlogn Abhi16  
/* Paste your code here (You may delete these lines if not writing code) */
 max You can calculate max product and construct BS tree at the same time. The time will still be O(N*lgN) and space O(N), but you need just one pass through array. int maxProduct( int[] arr ){ root = new Node(arr[0]); int maxProduct = 0; for( int i = 1; i < arr.length; i++ ){ int value = arr[i]; Deque<Integer> lessElems = new ArrayDeque<>(2); Node cur = root; Node prev = root; while( cur != null ){ prev = cur; if( cur.value <= value ){ if( lessElems.size() == 2 ){ lessElems.poll(); } lessElems.add( cur.value ); cur = cur.right; } else { cur = cur.left; } } if( value < prev.value ){ prev.left = new Node( value ); } else { prev.right = new Node( value ); } int curProduct = value; while( ! lessElems.isEmpty() ){ curProduct *= lessElems.poll(); } maxProduct = Math.max(maxProduct, curProduct); } return maxProduct; } Manish V @geeks 1.Create a MAX-STACK 2. Pop out 1st 3 elements Time complexity : O(n) max Won’t work for: {1, 2, 8, 3, 5, 7}; atul for building LSL[] in O(n) time … in similar way LGR[] is created ….in the same code we need to traverse from left to right instead of right to left.No need to adding AVL overhead.  
/* Paste your code here (You may delete these lines if not writing code) */
 AMIT try it yourself for array 5,7,3,10,8,6,2,9 LSL[] should be -1,5,-1,7,7,5,-1,8 If you can do it in o(n),then please let us know legalroot Can u explain what is meant by “For every element currently being traversed, we find the floor of it in AVL tree” with a example?  
/* Paste your code here (You may delete these lines if not writing code) */
 yelnatz What’s the floor of an AVL tree? kartik floor of an element here is the largest key (present in AVL current tree) such that the key is smaller than the given element. For example, floor of 42 is 40, floor of 20 is 18 in following AVL tree. 
      30
     /   \
   18     40
 /   \      \
6     22     50 zzer they must be a subsequence such that first<second <last Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
