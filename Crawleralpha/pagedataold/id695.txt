Print all nodes that are at distance k from a leaf node - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph Print all nodes that are at distance k from a leaf node Given a Binary Tree and a positive integer k, print all nodes that are distance k from a leaf node. Here the meaning of distance is different from previous post. Here k distance from a leaf means k levels higher than a leaf node. For example if k is more than height of Binary Tree, then nothing should be printed. Expected time complexity is O(n) where n is the number nodes in the given Binary Tree. We strongly recommend to minimize the browser and try this yourself first. The idea is to traverse the tree. Keep storing all ancestors till we hit a leaf node. When we reach a leaf node, we print the ancestor at distance k. We also need to keep track of nodes that are already printed as output. For that we use a boolean array visited[]. 
/* Program to print all nodes which are at distance k from a leaf */
#include <iostream>
using namespace std;
#define MAX_HEIGHT 10000

struct Node
{
    int key;
    Node *left, *right;
};

/* utility that allocates a new Node with the given key  */
Node* newNode(int key)
{
    Node* node = new Node;
    node->key = key;
    node->left = node->right = NULL;
    return (node);
}

/* This function prints all nodes that are distance k from a leaf node
   path[] --> Store ancestors of a node
   visited[] --> Stores true if a node is printed as output.  A node may be k
                 distance away from many leaves, we want to print it once */
void kDistantFromLeafUtil(Node* node, int path[], bool visited[],
                          int pathLen, int k)
{
    // Base case
    if (node==NULL) return;

    /* append this Node to the path array */
    path[pathLen] = node->key;
    visited[pathLen] = false;
    pathLen++;

    /* it's a leaf, so print the ancestor at distance k only
       if the ancestor is not already printed  */
    if (node->left == NULL && node->right == NULL &&
        pathLen-k-1 >= 0 && visited[pathLen-k-1] == false)
    {
        cout << path[pathLen-k-1] << " ";
        visited[pathLen-k-1] = true;
        return;
    }

    /* If not leaf node, recur for left and right subtrees */
    kDistantFromLeafUtil(node->left, path, visited, pathLen, k);
    kDistantFromLeafUtil(node->right, path, visited, pathLen, k);
}

/* Given a binary tree and a nuber k, print all nodes that are k
   distant from a leaf*/
void printKDistantfromLeaf(Node* node, int k)
{
    int path[MAX_HEIGHT];
    bool visited[MAX_HEIGHT] = {false};
    kDistantFromLeafUtil(node, path, visited, 0, k);
}

/* Driver program to test above functions*/
int main()
{
    // Let us create binary tree given in the above example
    Node * root = newNode(1);
    root->left = newNode(2);
    root->right = newNode(3);
    root->left->left = newNode(4);
    root->left->right = newNode(5);
    root->right->left = newNode(6);
    root->right->right = newNode(7);
    root->right->left->right = newNode(8);

    cout << "Nodes at distance 2 are: ";
    printKDistantfromLeaf(root, 2);

    return 0;
}
 Output: Nodes at distance 2 are: 3 1 Time Complexity: Time Complexity of above code is O(n) as the code does a simple tree traversal. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above           Related Topics: Perfect Binary Tree Specific Level Order Traversal Print Nodes in Top View of Binary Tree K Dimensional Tree Convert a Binary Tree to Threaded binary tree Serialize and Deserialize an N-ary Tree Serialize and Deserialize a Binary Tree Print nodes between two given level numbers of a binary tree Find Height of Binary Tree represented by Parent array Tweet Writing code in comment? Please use ideone.com and share the link here. Guest Hello geeks ,please check this code …i think this will do the work. its runtime is O(n) and O(1) space . #include #include #include typedef struct treeNode{ int data; struct treeNode *left; struct treeNode *right; }treeNode; struct treeNode* newNode(int num) { struct treeNode *t=(struct treeNode*)malloc(sizeof(struct treeNode)); if(t==NULL) printf(“nMalloc error . . .n”); t->left=NULL; t->right=NULL; t->data=num; return t; } int minimum(int a,int b) { return((aleft); printf(“%dt”,troot->data); printInorder(troot->right); } int k_distance_from_leaf(treeNode *troot,int m,int reqdDist) { if(troot==NULL) return 0; if(troot->left==NULL && troot->right==NULL) return 1; else { int k=m; int l=0; int r=0; if(k==0) l=k_distance_from_leaf(troot->left,k,reqdDist); else l=k_distance_from_leaf(troot->left,k+1,reqdDist); if(l!=0) k=l+1; else k++; r=k_distance_from_leaf(troot->right,k,reqdDist); if(m==reqdDist || l==2 || r==2) printf(“%dt”,troot->data); if(l==0) l=INT_MAX; if(r==0) r=INT_MAX; return(minimum(l,r)+1); } } int main() { int k=2; // Let us create the tree shown in above diagram struct treeNode *root = newNode(1); root->left = newNode(2); root->left->left = newNode(3); root->left->left->left = newNode(4); root->left->left->right = newNode(5); root->left->left->right->right = newNode(6); root->left->left->right->right->left = newNode(7); root->left->left->right->right->left->right = newNode(10); root->left->left->right->right->left->right->right = newNode(11); root->left->right = newNode(8); root->right = newNode(9); root->right->left = newNode(12); root->right->right = newNode(13); root->right->right->left = newNode(14); root->right->right->right = newNode(15); root->right->right->right->left = newNode(16); treeNode * root1 = newNode(1); root1->left = newNode(2); root1->right = newNode(3); root1->left->left = newNode(4); root1->left->right = newNode(5); root1->right->left = newNode(6); root1->right->right = newNode(7); root1->right->left->right = newNode(8); printf(“ntTree 1 :”); printf(“nInorder traversal for given tree . . .nt”); printInorder(root1); printf(“nn”); printf(“nNodes at distance %d from leaf are . . .nt”,k); k_distance_from_leaf(root1,0,k); printf(“nn”); printf(“ntTree 2 :”); printf(“nInorder traversal for given tree . . .nt”); printInorder(root); printf(“nn”); printf(“nNodes at distance %d from leaf are . . .nt”,k); k_distance_from_leaf(root,0,k); printf(“nn”); } guest Please check this approach ..O(n) time O(1) space. sunil A bottom up approach would be much simpler: int DistKfromLeaf(TreeNode* root, int k) { if(!root) return 0; int left = DistKfromLeaf(root->left, k); int right = DistKfromLeaf(root->right, k); if(left == k || right == k) std::cout <data << ' '; return min(left, right)+1; } Zheng Luo Should not the return min(left, right)+1 change to return max(left, right)+1?? gbRocks http://ideone.com/xWCNe2 I think ur bottomUp approach fails for this input.It prints only 1 as o/p but the ans should be 1 and 2.Please correct me if i am wrong. root = newNode(1); root->left = newNode(2); root->left->left = newNode(4); root->left->right = newNode(5); root->left->right->right = newNode(11); http://github.com/guptachirag Chirag I think it should be visited[path[pathLen-k-1]] instead of visited[pathLen-k-1] http://github.com/guptachirag Chirag I think it should be visited[path[pathLen-k-1]] instead of visited[pathLen-k-1] Smaug public boolean printNodesAtKDistanceFromLeaf(Node node, int k) { if (node == null) return false; if (node.left == null & node.right == null) { kDistance[0] = 1; return true; } if(printNodesAtKDistanceFromLeaf(node.left, k)&& kDistance[0]<= k){ System.out.println(node.left.data); } if(printNodesAtKDistanceFromLeaf(node.right, k)&& kDistance[0]<= k){ System.out.println(node.right.data); } kDistance[0]++; return true; } Guest int printK(Node * root, int k) { if(root == NULL) return 0; int m = printK(root->left, k); int n = printK(root->right, k); if(m == k) { printf(“%d “,root->key); if(n>0) return n+1; else return m+1; } else if(n == k) { printf(“%d “,root->key); if(m>0) return m+1; else return n+1; } if((m>k && nk && m<k)) return 1+minimum(m,n); else return 1+maximum(m,n); } prashant jha refer my full code http://ideone.com/gq9PJN gbRocks this is not an O(n) solution.Printing the output is taking O(k) time.So the worst case complexity of your code is O(n^2) I suppose. prashant jha use vector and recursion reach leaf nodes recursively and pop out k values from path and print last element in vector void fun(node* root,vector v,int k) { if(!root) return; if((!root->lchild)&(!root->rchild)) { v.push_back(root->data); vector:: iterator it; for(int i=0;i<k;i++) { v.pop_back(); } for(it=v.begin();it<v.end()-1;it++); cout<<*it<<" "; cout<data); fun(root->lchild,v,k); fun(root->rchild,v,k); } sam what is meant by line ” path[pathLen] = node->key;”; Jonathan Chen You are recording down the node value at index pathLen into the path array. So, when you hit a leaf node, you can look in the path array to see which values are k distance away it. ishant choukse one solution is calculate height of each node and compare with distance from leaf, its complexity is high but solution is very simple Suman Same logic I’ve implemented in below code.. Check out.. Also what complexity is high btw?? Suman This is working…. Space Complexity = O(1) Time Complexity = O(n) Let me know if its not working for some test cases… struct Node{ int key; Node *left, *right; }; /* utility that allocates a new Node with the given key */ Node* newNode(int key) { Node* node = new Node; node->key = key; node->left = node->right = NULL; return (node); } int maximum(int a, int b) { if(a>b) return a; else return b; } int printK(Node * root, int k) { if(root == NULL) return 0; int m = printK(root->left, k); int n = printK(root->right, k); if(m == k) { printf(“%d “,root->key); return n+1; } else if(n == k) { printf(“%d “,root->key); return m+1; } return 1+maximum(m,n); } int main() { // Let us create binary tree given in the above example Node * root = newNode(1); root->left = newNode(2); root->right = newNode(3); root->left->left = newNode(4); root->left->right = newNode(5); root->right->left = newNode(6); root->right->right = newNode(7); root->right->left->right = newNode(8); getchar(); return 0; } Girish Reddy Can you explain the approach? Suman Keep going to left or right node and while returning to parent node check whether the right link or left link height is equal to k. If equal to k then print the root info and pass the other sibling height. Else return 1+max(height of leftlink, height of rightlink) Girish Reddy Good Soln. Girish Reddy But why are you passing the other sibling’s height? Suman Plz check the updated code.. I ve made minor changes to pass all test cases… And for ur question – i’m passing other siblings height because passing same sibling’s height(which is k)+1 will never be equal to k again.. SO i’m passing other siblings height… As per updated code same sibling’s height will be passed when other sibling’s height is zero. Guest .Suman , can you explain what will be returned to parent node in case where both M and N are less than K (M<k&&N=k && n<k)||(m=k)) return min(n+1,m+1);// less than k is valuable only// if(m>=k && n>=k) return any of them: // both are useless further// but what?? for if(m<k && n<k) return ??? // both are valuable for ancestors Guest int printK(Node * root, int k) { if(root == NULL) return 0; int m = printK(root->left, k); int n = printK(root->right, k); if(m == k) { printf(“%d “,root->key); if(n>0) return n+1; else return m+1; } else if(n == k) { printf(“%d “,root->key); if(m>0) return m+1; else return n+1; } if((m>k && nk && m<k)) return 1+minimum(m,n); else return 1+maximum(m,n); } Suman when m and n are less than k, then 1+max(m,n) will be returned to parent node. Guest I came up with a similar solution but there is one thing you are missing, what if n > k && m < k , at this moment you should return the min(m, n) not the maximum since the maximum will make you miss to print the upper levels Suman How can n’s value surpass k’s value. I’ve put a check n==k and it ll b checked for every node. So it cant surpass the value of k. Once we print a root->info because of n==k, it ll return m’s value(as returning n’s value is useless for further upper nodes).. Also I would appreciate if you could come up with any such situation n explain it here with an example, then we will fix it.. Guest Yes buddy u r right.. And it ll happen in below scenario: 1 2 4 5 6 7 8 9 Lets take k=2.. Then 5 will be printed by m==k check and here n is also equal to k(problem occurs here when m==n==k.. As per my code i ll return 3 to node-2. Then at node-2 level both checks fail as mk and i’m returning max(m,n) which is not right.. Instead i ve to return min(m,n).. Below code might work for this scenario.. int printK(Node * root, int k) { if(root == NULL) return 0; int m = printK(root->left, k); int n = printK(root->right, k); if(m == k) { printf(“%d “,root->key); return n+1; } else if(n == k) { printf(“%d “,root->key); return m+1; } if(m>k && nk && m<k) return 1+minimum(m,n); else return 1+maximum(m,n); } Guest Yes buddy u r right.. Below code might work for your scenario.. int printK(Node * root, int k) { if(root == NULL) return 0; int m = printK(root->left, k); int n = printK(root->right, k); if(m == k) { printf(“%d “,root->key); return n+1; } else if(n == k) { printf(“%d “,root->key); return m+1; } if(m>k && nk && m<k) return 1+minimum(m,n); else return 1+maximum(m,n); } Guest U r right.. I should return minimum in such a case. Fixed Code: int printK(Node * root, int k) { if(root == NULL) return 0; int m = printK(root->left, k); int n = printK(root->right, k); if(m == k) { printf(“%d “,root->key); return n+1; } else if(n == k) { printf(“%d “,root->key); return m+1; } } Guest if((m>k && nk && m<k)) return 1+minimum(m,n); else return 1+maximum(m,n); Suman U r right.. I ve fixed the code for ur scenario.. But i ‘m not able to add n post it in correct format.. If i post it is taking differetly like below… Fixed code is below: //replace final return 1+maximum(m,n) with below lines if((m>k && nk && m<k)) return 1+minimum(m,n); else return 1+maximum(m,n); Guest if((m>k && nk && m<k)) return 1+minimum(m,n); else return 1+maximum(m,n); Guest if((m>k && nk && m<k)) return 1+minimum(m,n); else return 1+maximum(m,n); Guest if((m>k && nk && m<k)) return 1+minimum(m,n); else return 1+maximum(m,n); Guest if((m>k && nk && m<k)) return 1+minimum(m,n); else return 1+maximum(m,n); NITIN WRONG. you cant pass just minimum value…you need to keep track of both values kishor #include using namespace std; #define MAX_HEIGHT 10000 struct Node { int key; Node *left, *right; }; /* utility that allocates a new Node with the given key */ Node* newNode(int key) { Node* node = new Node; node->key = key; node->left = node->right = NULL; return (node); } /* This function prints all nodes that are distance k from a leaf node path[] –> Store ancestors of a node visited[] –> Stores true if a node is printed as output. A node may be k distance away from many leaves, we want to print it once */ /* Given a binary tree and a nuber k, print all nodes that are k distant from a leaf*/ int printKDistantfromLeaf(Node* node, int k) { if(node==NULL) return 0; else { int lc,rc; lc= printKDistantfromLeaf(node->left, k); rc =printKDistantfromLeaf(node->right, k); //cout<<lc<<" "<<rc<<" "<key<<endl; if(lc==k||rc==k) cout<key<<" ";; if(lc==0) return rc+1; else if(rc==0) return lc+1; return lcleft = newNode(2); root->right = newNode(3); root->left->left = newNode(4); root->left->right = newNode(5); root->right->left = newNode(6); root->right->right = newNode(7); root->right->left->right = newNode(8); root->right->left->right->right = newNode(10); cout << "Nodes at distance 2 are: "; printKDistantfromLeaf(root, 2); return 0; } geek_name 5 / 3 7 k=2 output 3 ,7..is it correct opcoder No dude. How it is correct? for your tree it won’t print anything as there is no node whose distance is 2 from any leaf node. You are confused about distance. Just count number of edges in the path, that will give you distance. geek_name 5 / 3 7 k=2 output 3 ,7..is it correct G.R. Karthik we can reduce extra space space requirement to ‘k+1′ by using the circular array/list data structure Code for the same: void kDistantFromLeafUtil(Node* node, Node *path[],int pathLen, int k) { // Base case if (node==NULL) return; int next_index = (pathLen+1) %k; if (node->left == NULL && node->right == NULL && path[next_index] != NULL) { cout <key <left, path, (pathLen+1)%k, k); kDistantFromLeafUtil(node->right, path, (pathLen+1)%k, k); path[pathLen] = NULL; } void printKDistantfromLeaf(Node* node, int k) { Node **path = new Node*[k+1]; for(int iter = 0; iter < k+1;iter++) path[iter] =NULL; kDistantFromLeafUtil(node, path, 0, k+1); delete[] path; } Please let me know if there is any thing wrong with this approach Nookesh Villuri int K_distanceFromLeaf(struct node *root,int k) { if(!root) return 0; else l=K_distanceFromLeaf(root->left,k); r=K_distanceFromLeaf(root->right,k); if(l==K||r==K) { printf(“%4d”,root->key); if(l==k&&r===K) return k; else return l!=k?(l<k?l+1:k+1):(r<k)?r+1:k+1; } if(l<k&&r=r?l+1;r+1; if(l>k&&r>k)return l<r?l+1:r+1; return l<k?l+1:r+1; } Nookesh Villuri is there any problem with this code Kid of Kop public int kDistanceFromLeaf(Tree root, int k) { if(root == null) return -1; int lDistance = 1 + kDistanceFromLeaf(root.left, k); int rDistance = 1 + kDistanceFromLeaf(root.right, k); int maxVal = Math.max(lDistance, rDistance); if (lDistance == k || rDistance ==k) System.out.println(root.value); return maxVal; } Coder011 Consider a right skewed tree, 1-2-3-4, with k=0, your code will output all nodes, whereas answer should be 4 Kid of Kop I hope this helps, k = 0 is a special case… public int kDistanceFromLeaf(Tree root, int k) { if(root == null) return -1; int lDistance = 1 + kDistanceFromLeaf(root.left, k); int rDistance = 1 + kDistanceFromLeaf(root.right, k); int maxVal = Math.max(lDistance, rDistance); if (k == 0) { if (lDistance == k && rDistance ==k) System.out.println(root.value); } else { if (lDistance == k || rDistance ==k) System.out.println(root.value); } return maxVal; } meh This approach doesn’t work since for every root it only knows about the maximum distance (height) of both of its children, however, multiple distances are possible for every possible path starting from the evaluated root (which grows exponentially in O(2^lgn) = O(n)) and you’d need to consider them all to see if they have k-distance. Take this worst-case example: Find all nodes at distance 2 from leaves: 1 2 / 6 3 / 7 4 / 8 5 Expected output: 1, 2, 3 Your output: 3 meh Damn, formatting was lost, going to print the tree using parenthesis (sorry if it’s hard to read): (1()(2(6)(3(7)(4(8)(5))))) Each parenthesis segment represents a node and starts with a number that is the value of the node following two parenthesis segments corresponding to the left and right children respectively. Kid of Kop I accept. code works only in balanced trees Rahman I think below line in kDistantFromLeafUtil is not required. visited[pathLen] = false; As we are setting it as false before calling the function itself. Please correct if I am wrong. meh It is actually required, the first time you go down in the recursion, as you travel down the left branch, all nodes are not visited. However, we you go up and start visiting a different branch, the values corresponding to the levels of the previously traveled branch will be left as visited unless you mark them as false explicitly when you’re going down the path. We need this because this a different branch and hence is not visited yet. Also, we need to mark them as visited since a given ancestor could meet the k-distance for multiple nodes on the same sub-tree. Chenzhan Liu I think we can do this: void printTreeNode(const TreeNode* p) { //to be implemented } void helper(TreeNode* p, vector& path, set& doneSet, int k) { if(p->left == NULL && p->right == NULL){ if(path.size() >= k && doneSet.count(p) == 0){ printTreeNode(path[path.size() – k]); doneSet.insert(p); } } else{ path.push_back(p); if(p->left != NULL) helper(p->left, path, doneSet, k); if(p->right != NULL) helper(p->right, path, doneSet, k); path.pop_back(); } } void printNodesAtDistanceFromLeaves(TreeNode* root, int k) { if(root == NULL) return; vector path; set doneSet; helper(root, path, doneSet, k); } meh I think this solution is pretty similar to the one explained in the post, though it’s obviously not the same and uses cooler data structures. Just a couple of things: I think you need to remove this part in the second if-expression: && doneSet.count(p) == 0 Basically, you’re saying that only one node can be at k-distance. nitpick: I believe set has O(lgn) lookup time, and you should use instead unordered_set in order to achieve O(n) total time. xxmajia Thanks for sharing. i think we should use a List to store the path, instead of the int[] path, since we might have duplicate Kartik here is another array visited[] that takes care of duplicates. Please let me know if it makes sense now. xxmajia not really, the visited array is for removing dup from the output eg: 1 / 2 3 if distance = 1, 1 will be printed twice, because 1 has 1 distance to 2 and 3. so you mark it as visited to avoid print it twice. but if the tree looks like 2 / 2 2 the parent[] array will go in a infinite loop Kartik It seems to be working fine for your example tree also. http://ideone.com/IZAmO6 Jonathan Chen The actual values inside each node wouldn’t affect whether the method worked or not because it don’t use them in any way to decide whether they have been printed or not. The only time the node values are used is when they are printed out. Paul will this code work for a tree as: 1 / 2 5 / 3 6 / 4 7 8 if 1 is root and k =4, will this tree not print 4 instead of 1? Paul the tree dint get printed as i wanted. its like the root (1) has a left and right child ( 2 and 5). 2 has only left child(3)..3 has only left child 4. and 5 has only right child 6..6 has only right child 7..7 has only right child 8. k=4 Coder011 @geeksforgeeks:disqus : I have a confusion regarding the question. In the given question if I suppose that, the node with value 4, has a left child of value 9. If I run the code (with k set as equal to 1) , Then shouldn’t the node 5 also be printed? ( Since it is 1 level above 9), or is it that we have to exclusively consider only those nodes which lie on the root to leaf path. Code : http://ideone.com/PH6uEh Guru Please share feedback about this code. I checked for certain cases and its working. public int printKNodesFromLeaf(BinaryTreeNode root, int k) { if (root == null) { return 0; } if (root.getLeft() == null && root.getRight() == null) { return 1; } int left = printKNodesFromLeaf(root.getLeft(), k); int right = printKNodesFromLeaf(root.getRight(), k); if (left == k || right == k) { System.out.println(root.getData()); return left + 1; } if (left < k && right < k) { return Math.max(left, right) + 1; } else if (left < k) { return left + 1; } else { return right + 1; } } Kartik This solution seems to have the same problem as the original solution posted by GeeksforGeeks, see the last three comments. Please correct me if i m wrong. Guru Thanks for the input. I have made a small modification to the code and hope this works public int printKNodesFromLeaf(BinaryTreeNode root, int k) { if (root == null) { return 0; } if (root.getLeft() == null && root.getRight() == null) { return 1; } int left = printKNodesFromLeaf(root.getLeft(), k); int right = printKNodesFromLeaf(root.getRight(), k); if (left == k || right == k) { System.out.println(root.getData()); } if (left < k && right < k) { return Math.max(left, right) + 1; } else if (left < k) { return left + 1; } else { return right + 1; } } Atul Add another check :- pathLen-k-1 > =0 Kartik This condition is already checked in above code. Please let me know if I missed anything. GeeksforGeeks Suraj, Vishal and Verma Shailendra, We have updated the post with a new approach. It handles all cases pointed by you. We appreciate your comments. vinith reddy podduturi As per the definition of distance between nodes presented here, http://www.geeksforgeeks.org/find-distance-two-given-nodes/. I dont think this approach would work if your distance k is more than the height of the tree. If for the given example k=5 say, then we want the result to be {4,5,8}. But in the code we are assuming k is always less than height (3). Is the question related to distance k or level k from a leaf node? Please clarify. GeeksforGeeks vinith, thanks for your inputs. To avoid confusion, we have added more details in question. GeeksforGeeks All, thanks for your inputs. The solution published above seems to have problems. We will correct it soon. Suraj this will not work because Height can not be a deciding factor here.Let say left subtree returns height of 5 but you can find a leaf at a distance 1,2_ _ _ 5.And if K=1 Then the node will not be printed according to your logic Vishal I think the logic is not correct. Suppose in the above tree we have a left child of node 4 (say 9) then what will be the nodes at a distance k=2 from the leaf nodes. node 1,node 2 and node 3 But according to your code we get node 2,node 3. opcoder No, it won’t. Have a closer look. Verma Shailendra I don’t think so this code will work in all cases, Just consider if there is a node as parent of 1 in above figure, than current 1 will return return max(2,3)+1 that is (4). If we find all the nodes at distance 3 from leaf nodes, it doesn’t include parent of 1. In my view we need to return a linked list from function printKDistantfromLeaf(); opcoder Run the code locally and see. It works. I agree we can also use linked list but then time complexity be > O(n) Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
