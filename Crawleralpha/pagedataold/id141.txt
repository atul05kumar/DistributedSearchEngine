Sorting Algorithms - GeeksQuiz GeeksQuiz Computer science mock tests for geeks Home Latest Questions Articles C/C++ Programs Contribute Books Subscribe 
 Sorting Please wait while the activity loads. If this activity does not load, try refreshing your browser. Also, this page requires javascript. Please visit using a browser with javascript enabled. If loading fails, click here to try again Question 1 What is recurrence for worst case of QuickSort and what is the time complexity in Worst case? A Recurrence is T(n) = T(n-2) + O(n) and time complexity is O(n^2) B Recurrence is T(n) = T(n-1) + O(n) and time complexity is O(n^2) C Recurrence is T(n) = 2T(n/2) + O(n) and time complexity is O(nLogn) D Recurrence is T(n) = T(n/10) + T(9n/10) + O(n) and time complexity is O(nLogn) Discuss it Question 1 Explanation:  The worst case of QuickSort occurs when the picked pivot is always one of the corner elements in sorted array. In worst case, QuickSort recursively calls one subproblem with size 0 and other subproblem with size (n-1). So recurrence is T(n) = T(n-1) + T(0) + O(n) The above expression can be rewritten as T(n) = T(n-1) + O(n) 1 Question 2 Suppose we have a O(n) time algorithm that finds median of an unsorted array. Now consider a QuickSort implementation where we first find median using the above algorithm, then use median as pivot. What will be the worst case time complexity of this modified QuickSort. A O(n^2 Logn) B O(n^2) C O(n Logn Logn) D O(nLogn) Discuss it Question 2 Explanation:  If we use median as a pivot element, then the recurrence for all cases becomes T(n) = 2T(n/2) + O(n) The above recurrence can be solved using Master Method. It falls in case 2 of master method. Question 3 Which of the following is not a stable sorting algorithm in its typical implementation. A Insertion Sort B Merge Sort C Quick Sort D Bubble Sort Discuss it Question 3 Explanation:  See following for details. http://www.geeksforgeeks.org/stability-in-sorting-algorithms/ Question 4 Which of the following sorting algorithms in its typical implementation gives best performance when applied on an array which is sorted or almost sorted (maximum 1 or two elements are misplaced). A Quick Sort B Heap Sort C Merge Sort D Insertion Sort Discuss it Question 4 Explanation:  Insertion sort takes linear time when input array is sorted or almost sorted (maximum 1 or 2 elements are misplaced). All other sorting algorithms mentioned above will take more than lienear time in their typical implementation. Question 5 Given an unsorted array. The array has this property that every element in array is at most k distance from its position in sorted array where k is a positive integer smaller than size of array. Which sorting algorithm can be easily modified for sorting this array and what is the obtainable time complexity? A Insertion Sort with time complexity O(kn) B Heap Sort with time complexity O(nLogk) C Quick Sort with time complexity O(kLogk) D Merge Sort with time complexity O(kLogk) Discuss it Question 5 Explanation:  See http://www.geeksforgeeks.org/nearly-sorted-algorithm/ for explanation and implementation. Question 6 Consider a situation where swap operation is very costly. Which of the following sorting algorithms should be preferred so that the number of swap operations are minimized in general? A Heap Sort B Selection Sort C Insertion Sort D Merge Sort Discuss it Question 6 Explanation:  Selection sort makes O(n) swaps which is minimum among all sorting algorithms mentioned above. Question 7 Which of the following is not true about comparison based sorting algorithms? A The minimum possible time complexity of a comparison based sorting algorithm is O(nLogn) for a random input array B Any comparison based sorting algorithm can be made stable by using position as a criteria when two elements are compared C Counting Sort is not a comparison based sorting algortihm D Heap Sort is not a comparison based sorting algorithm. Discuss it Question 7 Explanation:  See http://www.geeksforgeeks.org/lower-bound-on-comparison-based-sorting-algorithms/ for point A. See http://www.geeksforgeeks.org/stability-in-sorting-algorithms/ for B. C is true, count sort is an Integer Sorting algorithm. Question 8 Suppose we are sorting an array of eight integers using quicksort, and we have just finished the first partitioning with the array looking like this: 2 5 1 7 9 12 11 10 Which statement is correct? A The pivot could be either the 7 or the 9. B The pivot could be the 7, but it is not the 9 C The pivot is not the 7, but it could be the 9 D Neither the 7 nor the 9 is the pivot. Discuss it Question 9 Suppose we are sorting an array of eight integers using heapsort, and we have just finished some heapify (either maxheapify or minheapify) operations. The array now looks like this: 16 14 15 10 12 27 28 How many heapify operations have been performed on root of heap? A 1 B 2 C 3 or 4 D 5 or 6 Discuss it Question 9 Explanation:  In Heapsort, we first build a heap, then we do following operations till the heap size becomes 1. a) Swap the root with last element b) Call heapify for root c) reduce the heap size by 1. In this question, it is given that heapify has been called few times and we see that last two elements in given array are the 2 maximum elements in array. So situation is clear, it is maxheapify whic has been called 2 times. Question 10 What is the best time complexity of bubble sort? A N^2 B NlogN C N D N(logN)^2 Discuss it Question 10 Explanation:  The bubble sort is at its best if the input data is sorted. i.e. If the input data is sorted in the same order as expected output. This can be achieved by using one boolean variable. The boolean variable is used to check whether the values are swapped at least once in the inner loop. Consider the following code snippet: 1 Please observe that in the above code, the outer loop runs only once. Question 11 You have to sort 1 GB of data with only 100 MB of available main memory. Which sorting technique will be most appropriate? A Heap sort B Merge sort C Quick sort D Insertion sort Discuss it Question 11 Explanation:  The data can be sorted using external sorting which uses merging technique. This can be done as follows: 1. Divide the data into 10 groups each of size 100. 2. Sort each group and write them to disk. 3. Load 10 items from each group into main memory. 4. Output the smallest item from the main memory to disk. Load the next item from the group whose item was chosen. 5. Loop step #4 until all items are not outputted. The step 3-5 is called as merging technique. Question 12 What is the worst case time complexity of insertion sort where position of the data to be inserted is calculated using binary search? A N B NlogN C N^2 D N(logN)^2 Discuss it Question 12 Explanation:  Applying binary search to calculate the position of the data to be inserted doesn't reduce the time complexity of insertion sort. This is because insertion of a data at an appropriate position involves two steps: 1. Calculate the position. 2. Shift the data from the position calculated in step #1 one step right to create a gap where the data will be inserted. Using binary search reduces the time complexity in step #1 from O(N) to O(logN). But, the time complexity in step #2 still remains O(N). So, overall complexity remains O(N^2). Question 13 The tightest lower bound on the number of comparisons, in the worst case, for comparison-based sorting is of the order of A N B N^2 C NlogN D N(logN)^2 Discuss it Question 13 Explanation:  The number of comparisons that a comparison sort algorithm requires increases in proportion to Nlog(N), where N is the number of elements to sort. This bound is asymptotically tight: Given a list of distinct numbers (we can assume this because this is a worst-case analysis), there are N factorial permutations exactly one of which is the list in sorted order. The sort algorithm must gain enough information from the comparisons to identify the correct permutations. If the algorithm always completes after at most f(N) steps, it cannot distinguish more than 2^f(N) cases because the keys are distinct and each comparison has only two possible outcomes. Therefore, 2^f(N) >= N! or equivalently f(N) >= log(N!). Since log(N!) is Omega(NlogN), the answer is NlogN. For more details, read here Question 14 In a modified merge sort, the input array is splitted at a position one-third of the length(N) of the array. What is the worst case time complexity of this merge sort? A N(logN base 3) B N(logN base 2/3) C N(logN base 1/3) D N(logN base 3/2) Discuss it Question 14 Explanation:  The time complexity is given by: T(N) = T(N/3) + T(2N/3) + N Solving the above recurrence relation gives, T(N) = N(logN base 3/2) Question 15 Which sorting algorithm will take least time when all elements of input array are identical? Consider typical implementations of sorting algorithms. A Insertion Sort B Heap Sort C Merge Sort D Selection Sort Discuss it Question 15 Explanation:  The insertion sort will take [Tex]\theta[/Tex](n) time when input array is already sorted. Question 16 A list of n string, each of length n, is sorted into lexicographic order using the merge-sort algorithm. The worst case running time of this computation is (A) (B) (C) (D) A A B B C C D D Discuss it Question 16 Explanation:  The recurrence tree for merge sort will have height Log(n). And O(n^2) work will be done at each level of the recurrence tree (Each level involves n comparisons and a comparison takes O(n) time in worst case). So time complexity of this Merge Sort will be [Tex]O (n^2 log n) [/Tex]. Question 17 In quick sort, for sorting n elements, the (n/4)th smallest element is selected as pivot using an O(n) time algorithm. What is the worst case time complexity of the quick sort? (A) (n) (B) (nLogn) (C) (n^2) (D) (n^2 log n) A A B B C C D D Discuss it Question 17 Explanation:  The recursion expression becomes: T(n) = T(n/4) + T(3n/4) + cn After solving the above recursion, we get [Tex]\theta[/Tex](nLogn). Question 18 Consider the Quicksort algorithm. Suppose there is a procedure for finding a pivot element which splits the list into two sub-lists each of which contains at least one-fifth of the elements. Let T(n) be the number of comparisons required to sort n elements. Then A T(n) <= 2T(n/5) + n B T(n) <= T(n/5) + T(4n/5) + n C T(n) <= 2T(4n/5) + n D T(n) <= 2T(n/2) + n Discuss it Question 18 Explanation:  For the case where n/5 elements are in one subset, T(n/5) comparisons are needed for the first subset with n/5 elements, T(4n/5) is for the rest 4n/5 elements, and n is for finding the pivot. If there are more than n/5 elements in one set then other set will have less than 4n/5 elements and time complexity will be less than T(n/5) + T(4n/5) + n because recursion tree will be more balanced. Question 19 Which of the following sorting algorithms has the lowest worst-case complexity? A Merge Sort B Bubble Sort C Quick Sort D Selection Sort Discuss it Question 19 Explanation:  Worst case complexities for the above sorting algorithms are as follows: Merge Sort — nLogn Bubble Sort — n^2 Quick Sort — n^2 Selection Sort — n^2 Question 20 Which sorting algorithms is most efficient to sort string consisting of ASCII characters? A Quick sort B Heap sort C Merge sort D Counting sort Discuss it Question 20 Explanation:  Counting sort algorithm is efficient when range of data to be sorted is fixed. In the above question, the range is from 0 to 255(ASCII range). Counting sort uses an extra constant space proportional to range of data. Question 21 The number of elements that can be sorted in time using heap sort is 
(A) 
(B) 
(C) 
(d)  A A B B C C D D Discuss it Question 21 Explanation:  Time complexity of Heap Sort is [Tex]\Theta(mLogm)[/Tex] for m input elements. For m = [Tex]\Theta(Log n/(Log Log n))[/Tex], the value of [Tex]\Theta(m * Logm)[/Tex] will be [Tex]\Theta( [Log n/(Log Log n)] * [Log (Log n/(Log Log n))] )[/Tex] which will be [Tex]\Theta( [Log n/(Log Log n)] * [ Log Log n - Log Log Log n] )[/Tex] which is [Tex]\Theta(Log n)[/Tex] Question 22 Which of the following is true about merge sort? A Merge Sort works better than quick sort if data is accessed from slow sequential memory. B Merge Sort is stable sort by nature C Merge sort outperforms heap sort in most of the practical situations. D All of the above. Discuss it Question 23 Given an array where numbers are in range from 1 to n6, which sorting algorithm can be used to sort these number in linear time? A Not possible to sort in linear time B Radix Sort C Counting Sort D Quick Sort Discuss it Question 23 Explanation:  See Radix Sort for explanation. Question 24 In quick sort, for sorting n elements, the (n/4)th smallest element is selected as pivot using an O(n) time algorithm. What is the worst case time complexity of the quick sort? <pre> (A) (n) (B) (nLogn) (C) (n^2) (D) (n^2 log n) </pre>   A A B B C C D D Discuss it Question 24 Explanation:  Answer(B) The recursion expression becomes: T(n) = T(n/4) + T(3n/4) + cn After solving the above recursion, we get \theta(nLogn). Question 25 Consider the Quicksort algorithm. Suppose there is a procedure for finding a pivot element which splits the list into two sub-lists each of which contains at least one-fifth of the elements. Let T(n) be the number of comparisons required to sort n elements. Then A T(n) <= 2T(n/5) + n B T(n) <= T(n/5) + T(4n/5) + n C T(n) <= 2T(4n/5) + n D T(n) <= 2T(n/2) + n Discuss it Question 25 Explanation:  For the case where n/5 elements are in one subset, T(n/5) comparisons are needed for the first subset with n/5 elements, T(4n/5) is for the rest 4n/5 elements, and n is for finding the pivot. If there are more than n/5 elements in one set then other set will have less than 4n/5 elements and time complexity will be less than T(n/5) + T(4n/5) + n because recursion tree will be more balanced. Question 26 Let P be a QuickSort Program to sort numbers in ascending order using the first element as pivot. Let t1 and t2 be the number of comparisons made by P for the inputs {1, 2, 3, 4, 5} and {4, 1, 5, 3, 2} respectively. Which one of the following holds? A t1 = 5 B t1 < t2 C t1 > t2 D t1 = t2 Discuss it Question 26 Explanation:  When first element or last element is chosen as pivot, Quick Sort's worst case occurs for the sorted arrays. In every step of quick sort, numbers are divided as per the following recurrence. T(n) = T(n-1) + O(n) Question 27 You have an array of n elements. Suppose you implement quicksort by always choosing the central element of the array as the pivot. Then the tightest upper bound for the worst case performance is A O(n2) B O(nLogn) C Theta(nLogn) D O(n3) Discuss it Question 27 Explanation:  The central element may always be an extreme element, therefore time complexity in worst case becomes O(n2) Question 28 In a permutation a1.....an of n distinct integers, an inversion is a pair (ai, aj) such that i < j and ai > aj. What would be the worst case time complexity of the Insertion Sort algorithm, if the inputs are restricted to permutations of 1.....n with at most n inversions? A Θ (n2) B Θ (n log n) C Θ (n1.5) D Θ (n) Discuss it Question 28 Explanation:  Insertion sort runs in Θ(n + f(n)) time, where f(n) denotes the number of inversion initially present in the array being sorted. Source: http://cs.xidian.edu.cn/jpkc/Algorithm/down/Solution%20to%202-4%20Inversions.pdf There are 28 questions to complete. You have completed questions question Your score is Correct Wrong Partial-Credit You have not finished your quiz. If you leave this page, your progress will be lost. Correct Answer You Selected Not Attempted Final Score on Quiz Attempted Questions Correct Attempted Questions Wrong Questions Not Attempted Total Questions on Quiz Question Details Results Date Score Hint Time allowed minutes seconds Time used Answer Choice(s) Selected Question Text Need more practice! Keep trying! Not bad! Good work! Perfect!      Tweet Categories Articles (105) Algorithms (21) C (13) C++ (16) Data Structures (29) DBMS (1) Interview Experiences (6) Java (2) Operating Systems (1) Searching and Sorting (10) Programs (35) Quizzes (1,744) Aptitude (1) Computer Science Quizzes (1,742) Algorithms (147) C (207) C++ (129) Data Structures (132) DBMS (2) GATE (1,046) Java (51) Operating Systems (28) Web technologies (1) Recent Discussions Valid XHTML Strict 1.0 Powered by WordPress & MooTools | MiniMoo 1.3.4
