Dynamic Programming | Set 21 (Variations of LIS) - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph Dynamic Programming | Set 21 (Variations of LIS) We have discussed Dynamic Programming solution for Longest Increasing Subsequence problem in this post and a O(nLogn) solution in this post. Following are commonly asked variations of the standard LIS problem. 1. Building Bridges: Consider a 2-D map with a horizontal river passing through its center. There are n cities on the southern bank with x-coordinates a(1) … a(n) and n cities on the northern bank with x-coordinates b(1) … b(n). You want to connect as many north-south pairs of cities as possible with bridges such that no two bridges cross. When connecting cities, you can only connect city i on the northern bank to city i on the southern bank. 
8     1     4     3     5     2     6     7  
<---- Cities on the other bank of river---->
--------------------------------------------
  <--------------- River--------------->
--------------------------------------------
1     2     3     4     5     6     7     8
<------- Cities on one bank of river------->
 Source: Dynamic Programming Practice Problems. The link also has well explained solution for the problem. 2. Maximum Sum Increasing Subsequence: Given an array of n positive integers. Write a program to find the maximum sum subsequence of the given array such that the intgers in the subsequence are sorted in increasing order. For example, if input is {1, 101, 2, 3, 100, 4, 5}, then output should be {1, 2, 3, 100}. The solution to this problem has been published here. 3. The Longest Chain You are given pairs of numbers. In a pair, the first number is smaller with respect to the second number. Suppose you have two sets (a, b) and (c, d), the second set can follow the first set if b < c. So you can form a long chain in the similar fashion. Find the longest chain which can be formed. The solution to this problem has been published here. 4. Box Stacking You are given a set of n types of rectangular 3-D boxes, where the i^th box has height h(i), width w(i) and depth d(i) (all real numbers). You want to create a stack of boxes which is as tall as possible, but you can only stack a box on top of another box if the dimensions of the 2-D base of the lower box are each strictly larger than those of the 2-D base of the higher box. Of course, you can rotate a box so that any side functions as its base. It is also allowable to use multiple instances of the same type of box. Source: Dynamic Programming Practice Problems. The link also has well explained solution for the problem. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.           Related Topics: Job Sequencing Problem | Set 1 (Greedy Algorithm) Multiply two polynomials Algorithm Practice Question for Beginners | Set 1 Count Distinct Non-Negative Integer Pairs (x, y) that Satisfy the Inequality x*x + y*y < n Binomial Heap Print all increasing sequences of length k from first n natural numbers Find n’th number in a number system with only 3 and 4 Minimum Cost Polygon Triangulation Tags: Dynamic Programming Tweet Writing code in comment? Please use ideone.com and share the link here. xxmajia THANKS a lot Mandeep /* * To change this template, choose Tools | Templates * and open the template in the editor. */ package DynaProg; /** * * @author Pardeep */ public class buildingbridge { public static void main(String ar[]){ int cr[]={8,1,4,3,5,2,6,7}; int oth[]={1,2,3,4,5,6,7,8}; int othpos[]=new int[cr.length]; for(int i=0;i<oth.length;i++) //find the occurence of oth[] element in cr[] { int pos=0;boolean flag=false; for(int j=0;j<cr.length&&flag==false;j++){ if(oth[i]==cr[j]){ othpos[i]=j; flag=true;} else pos++; } } //for(int i=0;i<cr.length;i++) System.out.println(othpos[i]+1); int pos[]=new int[cr.length]; int brlength=0; for(int i=1;i<othpos.length;i++) { for(int j=i-1;j>=0;j–){ if(othpos[i]>=othpos[j]&&pos[j]+1>pos[i]){ pos[i]=pos[j]+1; brlength=pos[i]+1; //System.out.println(pos[i]+" "+i+" "+o); } } } System.out.println(brlength); } } GeeksforGeeks @Deep & @kalyan: The Box Stacking problem is also a variation of LIS problem. The problem is to construct maximum height stack. 1) We sort the boxes according to their increasing base areas (only a smaller base area box can be placed on top of another box). 2) After sorting the boxes, the problem is same as LIS. H(i) = Maximum possible stack height with box i at top of stack H(i) = { Max ( H(j) ) + height(i) } where j < i. If there is no such j then H(i) = height(i) To get overall maximum height, we need to return max(H(i)) where 0 < i < n We will soon publish it as a separate post. kalyan can u expplain the box stacking problem pls .. http://www.geeksforgeeks.org/archives/19255 deep on the given link i am not getting The Box Stacking problem. can anyone explain it?  
/* Paste your code here (You may delete these lines if not writing code) */
 http://www.geeksforgeeks.org/archives/19255 DEEP on the given link i am not getting The Box Stacking problem. can anyone explain it? Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
