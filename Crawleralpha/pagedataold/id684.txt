Remove all nodes which don't lie in any path with sum>= k  - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph Remove all nodes which don’t lie in any path with sum>= k Given a binary tree, a complete path is defined as a path from root to a leaf. The sum of all nodes on that path is defined as the sum of that path. Given a number K, you have to remove (prune the tree) all nodes which don’t lie in any path with sum>=k. Note: A node can be part of multiple paths. So we have to delete it only in case when all paths from it have sum less than K. 
Consider the following Binary Tree
          1 
      /      \
     2        3
   /   \     /  \
  4     5   6    7
 / \    /       /
8   9  12      10
   / \           \
  13  14         11
      / 
     15 

For input k = 20, the tree should be changed to following
(Nodes with values 6 and 8 are deleted)
          1 
      /      \
     2        3
   /   \        \
  4     5        7
   \    /       /
    9  12      10
   / \           \
  13  14         11
      / 
     15 

For input k = 45, the tree should be changed to following.
      1 
    / 
   2   
  / 
 4  
  \   
   9    
    \   
     14 
     /
    15 


 We strongly recommend you to minimize the browser and try this yourself first. The idea is to traverse the tree and delete nodes in bottom up manner. While traversing the tree, recursively calculate the sum of nodes from root to leaf node of each path. For each visited node, checks the total calculated sum against given sum “k”. If sum is less than k, then free(delete) that node (leaf node) and return the sum back to the previous node. Since the path is from root to leaf and nodes are deleted in bottom up manner, a node is deleted only when all of its descendants are deleted. Therefore, when a node is deleted, it must be a leaf in the current Binary Tree. Following is C implementation of the above approach. 
#include <stdio.h>
#include <stdlib.h>

// A utility function to get maximum of two integers
int max(int l, int r) { return (l > r ? l : r); }

// A Binary Tree Node
struct Node
{
    int data;
    struct Node *left, *right;
};

// A utility function to create a new Binary Tree node with given data
struct Node* newNode(int data)
{
    struct Node* node = (struct Node*) malloc(sizeof(struct Node));
    node->data = data;
    node->left = node->right = NULL;
    return node;
}

// print the tree in LVR (Inorder traversal) way.
void print(struct Node *root)
{
    if (root != NULL)
    {
        print(root->left);
        printf("%d ",root->data);
        print(root->right);
    }
}

/* Main function which truncates the binary tree. */
struct Node *pruneUtil(struct Node *root, int k, int *sum)
{
    // Base Case
    if (root == NULL)  return NULL;

    // Initialize left and right sums as sum from root to
    // this node (including this node)
    int lsum = *sum + (root->data);
    int rsum = lsum;

    // Recursively prune left and right subtrees
    root->left = pruneUtil(root->left, k, &lsum);
    root->right = pruneUtil(root->right, k, &rsum);

    // Get the maximum of left and right sums
    *sum = max(lsum, rsum);

    // If maximum is smaller than k, then this node
    // must be deleted
    if (*sum < k)
    {
        free(root);
        root = NULL;
    }

    return root;
}

// A wrapper over pruneUtil()
struct Node *prune(struct Node *root, int k)
{
    int sum = 0;
    return pruneUtil(root, k, &sum);
}

// Driver program to test above function
int main()
{
    int k = 45;
    struct Node *root = newNode(1);
    root->left = newNode(2);
    root->right = newNode(3);
    root->left->left = newNode(4);
    root->left->right = newNode(5);
    root->right->left = newNode(6);
    root->right->right = newNode(7);
    root->left->left->left = newNode(8);
    root->left->left->right = newNode(9);
    root->left->right->left = newNode(12);
    root->right->right->left = newNode(10);
    root->right->right->left->right = newNode(11);
    root->left->left->right->left = newNode(13);
    root->left->left->right->right = newNode(14);
    root->left->left->right->right->left = newNode(15);

    printf("Tree before truncation\n");
    print(root);

    root = prune(root, k); // k is 45

    printf("\n\nTree after truncation\n");
    print(root);

    return 0;
}
 Output: Tree before truncation
8 4 13 9 15 14 2 12 5 1 6 3 10 11 7

Tree after truncation
4 9 15 14 2 1 Time Complexity: O(n), the solution does a single traversal of given Binary Tree. This article is contributed by Chandra Prakash. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.           Related Topics: Perfect Binary Tree Specific Level Order Traversal Print Nodes in Top View of Binary Tree K Dimensional Tree Convert a Binary Tree to Threaded binary tree Serialize and Deserialize an N-ary Tree Serialize and Deserialize a Binary Tree Print nodes between two given level numbers of a binary tree Find Height of Binary Tree represented by Parent array Tweet Writing code in comment? Please use ideone.com and share the link here. gaurav Simple solution http://ideone.com/y23b3u Gopi #include”tree.h” struct tree* sum_less_pruning(struct tree *root, int benchmark, int match) { if(root == NULL) return ; match+=root->data; root->left=sum_less_pruning(root->left,benchmark,match); root->right=sum_less_pruning(root->right,benchmark,match); if(root->left == NULL && root->right == NULL && matchleft = newnode(2); root->right = newnode(3); root->left->left = newnode(4); root->left->right = newnode(5); root->right->left = newnode(6); root->right->right = newnode(7); root->left->left->left = newnode(8); root->left->left->right = newnode(9); root->left->right->left = newnode(12); root->right->right->left = newnode(10); root->right->right->left->right = newnode(11); root->left->left->right->left = newnode(13); root->left->left->right->right = newnode(14); root->left->left->right->right->left = newnode(15); //Find sum_root+leaf root = sum_less_pruning(root,45,0); inorder(root); printf(“n”); } viswa public Node removeksum(Node root , int sum , int total ) { if(root == null ) return null; if(root.left == null && root.right == null) { if(sum+root.data < total) return null; else return root; } root.left = removeksum(root.left , sum+root.data , total ); root.right = removeksum(root.right , sum+root.data , total ); if( root.left != null || root.right != null ) return root; else return null; } moldyshots int removePaths(Node* n, int sum, int K) { if(n == NULL) { return 0; } sum += n->value; if( isLeaf(n) && sum left, sum, K) right, sum, K) < K) { free(n); n = NULL; return sum; } return sum; } } Guest int removePaths(Node* n, int sum) { if(n == NULL) { return 0; } sum += n->value; if( isLeaf(n) && sum left, sum) right, sum) <K) { free(n); n = NULL; return sum; } return sum; } } Guest int removePaths(Node* n, int sum) { if(n == NULL) { return 0; } sum += n->value; if( isLeaf(n) && sum left, sum) right, sum) <K) { free(n); n = NULL; return sum; } return sum; } } Guest int removePaths(Node* n, int sum) { if(n == NULL) { return 0; } sum += n->value; if( isLeaf(n) && sum left, sum) right, sum) <K) { free(n); n = NULL; return sum; } return sum; } } hj public class RemoveNodesNotOnPath { public Node pruneTree(Node node, int k, int sum) { if (node == null ) return null; sum = sum + node.getValue(); node.setLeft(pruneTree(node.getLeft(), k, sum)); node.setRight(pruneTree(node.getRight(), k, sum)); if (sum < k && node.getLeft() == null && node.getRight() == null) { node = null; } return node; } } public class Node { private int value; private Node left; private Node right; public Node(int val) { value = val; left = null; right = null; } public int getValue() { return value; } public void setRight(Node right) { this.right = right; } public Node getRight() { return right; } public void setLeft(Node left) { this.left = left; } public Node getLeft() { return left; } public void print() { if (this != null) { if (left != null)left.print(); System.out.print(" " + value); if (right != null)right.print(); } } } Driver function: public static void main(String args[]) { Node root = new Node(1); root.setLeft(new Node(2)); root.setRight(new Node(3)); root.getLeft().setLeft(new Node(4)); root.getLeft().setRight(new Node(5)); root.getRight().setLeft(new Node(6)); root.getRight().setRight(new Node(7)); root.getLeft().getLeft().setLeft(new Node(8)); root.getLeft().getLeft().setRight(new Node(9)); root.getLeft().getRight().setLeft(new Node(12)); root.getRight().getRight().setLeft(new Node(10)); root.getRight().getRight().getLeft().setRight(new Node(11)); root.getLeft().getLeft().getRight().setLeft(new Node(13)); root.getLeft().getLeft().getRight().setRight(new Node(14)); root.getLeft().getLeft().getRight().getRight().setLeft(new Node(15)); int k = 45; System.out.println("Tree before pruning"); root.print(); root = new RemoveNodesNotOnPath().pruneTree(root, k, 0); System.out.println(""); System.out.println("Tree after pruning"); root.print(); } smith struct node *edit(struct node *root,int k) { if(root==NULL)return NULL; if(root->data>=k)return root; root->left=edit(root->left,k-root->data); root->right=edit(root->right,k-root->data); if((root->left==NULL&&root->right==NULL)) return NULL; else return root; smith is thr any case missng in above solution?? Nikhil Shouldn’t in the example with k=20, the tree with 5-12 be pruned too? The explanation says only about node 6 and 8. Or am I missing something? GuruSimhe The node to be deleted–> sum < K. Javed This code doesnt need lsum and rsum: /* Main function which truncates the binary tree. */ struct Node *pruneUtil(struct Node *root, int k, int sum) { /*Base Case*/ if (root == NULL) return NULL; /* Update Sum*/ sum = sum + (root->data); /* Recursively prune left and right subtrees*/ root->left = pruneUtil(root->left, k, sum); root->right = pruneUtil(root->right, k, sum); /* If maximum is smaller than k, and this is a leaf node then it must be deleted*/ if (sum left==NULL && root->right==NULL) { free(root); root = NULL; } return root; } /* A wrapper over pruneUtil()*/ struct Node *prune(struct Node *root, int k) { int sum = 0; return pruneUtil(root, k, sum); } Anirban Saha Yes i feel the same too .. Is there any boundary condition i am missing ? Sreenivas Doosa Excellent. would be fine for all the cases. Utkarsh Cool..! But i always get confused with algorithms involving such codes with lsum, rsum… sid public int check(node root,int k,int sum) { if(root==null) { if(sum<k) return 1; else return 0; } else if(root.getLeft()==null&&root.getRight()==null) { sum=sum+root.getData(); if(sum<k) return 1; else return 0; } else { sum=sum+root.getData(); int l=check(root.getLeft(),k,sum); int r=check(root.getRight(),k,sum); if(l==1) root.setLeft(null); if(r==1) root.setRight(null); if(l==1&&r==1) return 1; else return 0; } } sid public int check(node root,int k,int sum) { if(root==null) { if(sum<k) return 1; else return 0; } else if(root.getLeft()==null&&root.getRight()==null) { sum=sum+root.getData(); if(sum<k) return 1; else return 0; } else { sum=sum+root.getData(); int l=check(root.getLeft(),k,sum); int r=check(root.getRight(),k,sum); if(l==1) root.setLeft(null); if(r==1) root.setRight(null); if(l==1&&r==1) return 1; else return 0; } } shivam #include #include #include using namespace std; typedef struct Node { int data; struct Node *left, *right; }node; // print the tree in LVR (Inorder traversal) way. struct Node* newNode(int data) { struct Node* node = (struct Node*) malloc(sizeof(struct Node)); node->data = data; node->left = node->right = NULL; return node; } void print(struct Node *root) { if (root != NULL) { print(root->left); printf(“%d “,root->data); print(root->right); } } node* pruneutil(node* root,int k,int sum) { if(root==NULL) return NULL; sum+=root->data; root->left=pruneutil(root->left,k,sum); root->right=pruneutil(root->right,k,sum);//im postorder manner if(sum>=k ||(root->left||root->right)) return root;// non null value signifies it exists in a valid path.propagate it through leaves else return NULL; } struct Node *prune(struct Node *root, int k) { return pruneutil(root, k,0);//sum is 0 initially } // Driver program to test above function int main() { int k = 45; struct Node *root = newNode(1); root->left = newNode(2); root->right = newNode(3); root->left->left = newNode(4); root->left->right = newNode(5); root->right->left = newNode(6); root->right->right = newNode(7); root->left->left->left = newNode(8); root->left->left->right = newNode(9); root->left->right->left = newNode(12); root->right->right->left = newNode(10); root->right->right->left->right = newNode(11); root->left->left->right->left = newNode(13); root->left->left->right->right = newNode(14); root->left->left->right->right->left = newNode(15); printf(“Tree before truncationn”); print(root); root = prune(root, k); // k is 45 printf(“nnTree after truncationn”); print(root); return 0; } Rohit Can anyone please explain me the example? I didn’t get how removing 8 and 6 helped. There are still other paths whose sum >= k and the none of the node in the path overlaps. prashant #include #include #define size 50 using namespace std; struct tnode { tnode* lchild; int data; tnode* rchild; }; void insert(tnode*&,int); int del(tnode*&,int); void display(tnode*); int main() { int d;int choice,no,h,k; tnode* root=NULL; while(1) { cout<<"n"; cout<<"menu.n"; cout<<"1.insert.n"; cout<<"2.give no.n"; cout<<"2.display.n"; cout<>choice; switch(choice) { case 1: cout<>d; insert(root,d); break; case 2: cout<>no; k=del(root,no); break; case 3: display(root); break; case 4: exit(1) ; } } return 0; } void insert(tnode* &root,int d) { int d1; if(d==-1) return; if(root==NULL) { tnode* temp=new tnode; temp->data=d; temp->rchild=NULL; temp->lchild=NULL; root=temp; } cout<<"entet the left child of "<data<>d1; insert(root->lchild,d1); cout<<"entert the right child of "<data<>d1; insert(root->rchild,d1); } int del(tnode* &root,int k) { if(k<=0) return 0; if((root==NULL)&&(k0)) return 1; int f1=del(root->lchild,k-(root->data)); int f2=del(root->rchild,k-(root->data)); if((f1==1)&&(f2==1)) { root=NULL; return 1; } else return 0; } void display(tnode* root) { if(root!=NULL) { display(root->lchild); cout<data<rchild); } } sijayaraman void del(struct node* &root,int sum,int num) { if(root==NULL) { return; } sum = sum + root->data; del(root->left,sum,num); del(root->right,sum,num); if(root->left == NULL && root->right==NULL) { if(sum < num) { delete root; root=NULL; } } } Yash Girdhar If we subtract the sum from the k, instead of calculating the sum, we don’t need to go up to the leaf node every time,although in worst case, order would be same. int convert(node *start,int k){ // printf("x=%d k=%dn",start->data,k ); k = k - start->data; if(k left && !start->right){ if(k left){ left = convert(start->left,k); // printf("x=%d left=%dn",start->data,left ); } if(left == -1) start->left=NULL; if(start->right){ right = convert(start->right,k); // printf("x=%d right=%dn",start->data,right ); } if(right == -1) start->right = NULL; if(left==-1 && right==-1){ // printf("x=%d returning -1n",start->data); return -1; } else return 1; } Harinath Pathuri Small Optimisation: If (root->data > k){ //Both left and right subtrees of “root” are on the path. //So we need not traverse down. } Ashok How abt this?? static BTNode removeNodes(BTNode node,int sum,int k) { if(node==null) return null; sum=sum+node.getData(); node.setLeft(removeNodes(node.getLeft(), sum, k)); node.setRight(removeNodes(node.getRight(), sum, k)); if(node.getLeft()==null && node.getRight()==null) { System.out.println(sum); if(sum<k) { return null; } } return node; } Anil if (*sum < k) { free(root); root = NULL; *sum -= max(lsum, rsum); /* Why? this statement is not in the code. I see the flaw but dont have usecase for it */ } Cheng #include #include #include using namespace std; struct node{ int data; node *left, *right; }; class tree{ private: node *root; public: tree() { root = NULL; } void add(int data) { node *q = new node; q->data = data; if(root==NULL) { root = q; } else { node *tail, *cur; cur = root; while(cur) { tail = cur; if(cur->data right; else cur = cur->left; } if(tail->data right = q; else tail->left = q; } } void print(node *cur) { if(cur) { print(cur->left); cout<data<right); } } void printtree() { cout<<"nPrinitng treen"; print(root); cout<<endl; } void printpath(int *path, int pathlen) { cout<<"nPath -- "; for(int i=0; i<pathlen; i++) { cout<<path[i]<data; pathlen++; if(!cur->left && !cur->right) printpath(path,pathlen); else { findpath(cur->left,path,pathlen); findpath(cur->right,path,pathlen); } } } void pathcall() { cout<<"nPrinitng all pathsn"; int *path = new int[100]; int pathlen = 0; findpath(root,path,pathlen); cout<<endl; } }; int main() { srand(time(NULL)); int N = 15; tree T; for(int i=0; i<N; i++) { int d = 1+rand()%20; T.add(d); cout<<d<<" "; } T.printtree(); T.pathcall(); } Jasprit void pruneUtil(struct node **node, int k ,int sum) { if (*node == NULL) return; sum += (*node)->data; pruneUtil(&((*node)->left), k, sum); pruneUtil(&((*node)->right), k, sum); if(isLeaf(*node)) { if (sum data; *node = NULL; } } } struct node* prune(struct node *root, int k) { if (root == NULL) return NULL; int sum = 0; pruneUtil(&root, k, sum); return root; } Praneeth RemoveNodefromSum(Node r, int sum) { if (root.data>=sum) return true; //IF sum is reached no need to go furthur down if (!root.hasleft && !root.hasright) { delete(this) return false; //If sum is not yet reached and we dont have anything to go down then return false } else { boolean b= false; boolean c= false; if(root.hasleft) { b = RemoveNodefromSum(r.left, sum-data); } if(root.hasright) { c = RemoveNodefromSum(r.right, sum-data); } if(!(b||c)) { delete(this) return false; } } return true; } Archit you don’t need to go upto leaf node in case your sum from root to current is greater than or equal to K. From this node, u can return with guarantee that your aim is achieved after this subtree. if(lsum >= k) return; Archit if(lsum >= k) return root; GFG good one, need to add checks when tree has negative nodes! Nitin Sharma PLEASE CAN ANYONE TELL ME WHY MY PROGRAM IS GIVING ME A WRONG ANSWER? truncate-> this is a function which should give the tree after the given conditions I have called truncate(root,NULL,0,0) from main. void truncate(node *root, node *prev , int sum,int left) { if(root!=NULL) { sum+=root->data; truncate(root->left,root,sum,1); if(root->right == NULL && root->left == NULL) { if(sum left = NULL; } else { prev->right = NULL; } } } else { truncate(root->right,root,sum,0); } } } Guest PLEASE CAN ANYONE TELL ME WHY MY PROGRAM IS GIVING ME A WRONG ANSWER? truncate-> this is a function which should give the tree after the given conditions I have called truncate(root,NULL,0,0) from main. void truncate(node *root, node *prev , int sum,int left) { if(root!=NULL) { sum+=root->data; truncate(root->left,root,sum,1); Share if(root->right == NULL && root->left == NULL) { if(sum left = NULL; } else { prev->right = NULL; } } } else { truncate(root->right,root,sum,0); } } } Guest PLEASE CAN ANYONE TELL ME WHY MY PROGRAM IS GIVING ME A WRONG ANSWER? truncate-> this is a function which should give the tree after the given conditions I have called truncate(root,NULL,0,0) from main. void truncate(node *root, node *prev , int sum,int left) { if(root!=NULL) { sum+=root->data; truncate(root->left,root,sum,1); if(root->right == NULL && root->left == NULL) { if(sum left = NULL; } else { prev->right = NULL; } } } else { truncate(root->right,root,sum,0); } } } Shobhit Tulsyan Another solution is: void removeNodes(struct node **root, int k) { static int sum = 0; //Base case if((*root) == NULL) return; sum += (*root)->data; removeNodes(&(*root)->left, k); removeNodes(&(*root)->right, k); if((*root)->left == NULL && (*root)->right == NULL) { if(sum data; free(*root = NULL); return; } else { sum -= (*root)->data; return; } } sum -= (*root)->data; } ocean this way sum is adding data of all nodes. its not differentiating between data of left and right subtree.. so I guess this is wrong Thien Nguyen Small improve : change k to k – node->data when move to its children. /* Main function which truncates the binary tree. */ struct Node *prune(struct Node *root, int k) { // Base Case if (root == NULL) return NULL; // Recursively prune left and right subtrees root->left = prune(root->left, k-root->data); root->right = prune(root->right, k-root->data); // If it is the leaf and its data is smaller than k, then this node // must be deleted if (root->left == NULL && root->right == NULL && root->data < k) { free(root); root = NULL; } return root; } thienpnguyen Small improve : change k to k – node->data when move to its children. /* Main function which truncates the binary tree. */ struct Node *prune(struct Node *root, int k) { // Base Case if (root == NULL) return NULL; // Recursively prune left and right subtrees root->left = prune(root->left, k-root->data); root->right = prune(root->right, k-root->data); // If maximum is smaller than k, then this node // must be deleted if (root->left == NULL && root->right == NULL && root->data < k) { free(root); root = NULL; } return root; } Kuldeep Kumar #include #include #include using namespace std; typedef struct bst{ struct bst*left; int data; struct bst*right; }node; node *prev=NULL; node* create(node*t,int d){ node *temp; if(t==NULL){ temp=(node*)malloc(sizeof(node)); temp->right=NULL; temp->left=NULL; temp->data=d; t=temp; return temp; } else if(t->data>d){ if(t->left) create(t->left,d); else t->left=create(t->left,d); } else if(t->dataright) create(t->right,d); else t->right=create(t->right,d); } } int kpath(node*t,int sum){ if ( (sum-t->data) left && !t->right && ( sum - t->data )>0){ if(prev){ if( prev->left == t ) prev->left = NULL; else prev->right = NULL; } return 0; } else { if( t->left && t->right ){ int flag=0; node *pprev; pprev=prev; prev=t; flag=kpath( t->left , ( sum-t->data ) ) || kpath( t->right , ( sum-t->data ) ); if( flag == 0 && pprev ){ if( pprev->left == t ) pprev->left = NULL; else pprev->right = NULL; return 0; } else if ( flag==0 && pprev==NULL ) return 0; return 1; } else if(t->left || t->right){ int flag=0; node *pprev; pprev=prev; prev=t; flag=t->left!=NULL ? kpath( t->left , ( sum-t->data ) ):kpath( t->right , ( sum-t->data ) ); if ( flag == 0 && pprev ) { if( pprev->left == t ) pprev->left = NULL; else pprev->right = NULL; return 0; } else if( flag==0 && pprev==NULL ) return 0; return 1; } } } void preorder(node*t){ if(t){ cout<data<"; preorder(t->left); preorder(t->right); } } int main(){ node *t=NULL,*root; root=create(t,5); create(root,9); create(root,3); cout<<"Before:"; preorder(root); cout<<"nAfter:"; if(kpath(root,14)) preorder(root); else{ root=NULL; cout<<"nTree deleted:"; } return 0; } Kuldeep Kumar #include #include #include using namespace std; typedef struct bst{ struct bst*left; int data; struct bst*right; }node; node *prev=NULL; node* create(node*t,int d){ node *temp; if(t==NULL){ temp=(node*)malloc(sizeof(node)); temp->right=NULL; temp->left=NULL; temp->data=d; t=temp; return temp; } else if(t->data>d){ if(t->left) create(t->left,d); else t->left=create(t->left,d); } else if(t->dataright) create(t->right,d); else t->right=create(t->right,d); } } int kpath(node*t,int sum){ if ( (sum-t->data) left && !t->right && ( sum - t->data )>0){ if(prev){ if( prev->left == t ) prev->left = NULL; else prev->right = NULL; } return 0; } else { if( t->left && t->right ){ int flag=0; node *pprev; pprev=prev; prev=t; flag=kpath( t->left , ( sum-t->data ) ) || kpath( t->right , ( sum-t->data ) ); if( flag == 0 && pprev ){ if( pprev->left == t ) pprev->left = NULL; else pprev->right = NULL; return 0; } else if ( flag==0 && pprev==NULL ) return 0; return 1; } else if(t->left || t->right){ int flag=0; node *pprev; pprev=prev; prev=t; flag=t->left!=NULL ? kpath( t->left , ( sum-t->data ) ):kpath( t->right , ( sum-t->data ) ); if ( flag == 0 && pprev ) { if( pprev->left == t ) pprev->left = NULL; else pprev->right = NULL; return 0; } else if( flag==0 && pprev==NULL ) return 0; return 1; } } } void preorder(node*t){ if(t){ cout<data<"; preorder(t->left); preorder(t->right); } } int main(){ node *t=NULL,*root; root=create(t,5); create(root,9); create(root,3); cout<<"Before:"; preorder(root); cout<<"nAfter:"; if(kpath(root,14)) preorder(root); else{ root=NULL; cout<<"nTree deleted:"; } return 0; } tonmoy #include #include typedef struct tree { int data; struct tree *left; struct tree *right; }node; node* newNode(int data) { node *tmp; tmp = (node*)malloc(sizeof(node)); tmp->data = data; tmp->left = NULL; tmp->right = NULL; return tmp; } void traverse(node *n) { printf(“%dt”,n->data); if(n->left) traverse(n->left); if(n->right) traverse(n->right); } int findsum(node *root,int sum) { int x,y; sum = sum-root->data; printf(“%dn”,sum); if(sumleft) x = findsum(root->left,sum); if(root->right) y = findsum(root->right,sum); if(x==0) root->left = NULL; if(y==0) root->right = NULL; if(!root->left&&!root->right) return 0; } int main() { node *root; root = (node*)malloc(sizeof(node)); root->data = 1; root->left = newNode(2); root->right = newNode(3); root->left->left = newNode(4); root->left->right = newNode(5); root->right->left = newNode(6); root->right->right = newNode(7); root->left->left->left = newNode(8); root->left->left->right = newNode(9); root->left->right->left = newNode(12); root->right->right->left = newNode(10); root->right->right->left->right = newNode(11); root->left->left->right->left = newNode(13); root->left->left->right->right = newNode(14); root->left->left->right->right->left = newNode(15); node *tmp; int sum,x; tmp = root; traverse(tmp); printf(“n”); tmp = root; printf(“Enter the sum:n”); scanf(“%d”,&sum); x=findsum(tmp,sum); tmp = root; traverse(tmp); printf(“n”); } tonmoy #include #include typedef struct tree { int data; struct tree *left; struct tree *right; }node; node* newnode(int data) { node *tmp; tmp = (node*)malloc(sizeof(node)); tmp->data = data; tmp->left = NULL; tmp->right = NULL; return tmp; } void traverse(node *n) { printf(“%dt”,n->data); if(n->left) traverse(n->left); if(n->right) traverse(n->right); } int findsum(node *root,int sum) { int x,y; sum = sum-root->data; printf(“%dn”,sum); if(sumleft&&!root->right) return 0; if(root->left) x = findsum(root->left,sum); if(root->right) y = findsum(root->right,sum); if(x==1) root->left = NULL; if(y==1) root->right = NULL; } int main() { node *root; root = (node*)malloc(sizeof(node)); root->data = 1; root->left = newnode(2); root->right = newnode(3); root->left->left = newnode(4); root->left->right = newnode(5); root->right->left = newnode(6); root->left->left->left = newnode(7); node *tmp; int sum,x; tmp = root; traverse(tmp); printf(“n”); tmp = root; printf(“Enter the sum:n”); scanf(“%d”,&sum); x=findsum(tmp,sum); tmp = root; traverse(tmp); printf(“n”); } Saurabh Below code should also work: public boolean delete(Node root, int sum){ if(root == null) return sum <= 0; if(root.left == null && root.right == null) return (sum - root.value) <= 0 ; boolean left = delete(root.left, sum - root.value); boolean right = delete(root.right, sum - root.value); if(!left) root.left = null; if(!right) root.right = null; return (left || right); } empo A simple java solution :: private static int remove(Node root,int sum,int k) { if(root == null) return sum; int m = Math.max(remove(root.left,sum+root.data,k),remove(root.right,sum+root.data,k); if(isLess(m,k)) root.data = -1; return m; } ‘Abhishek Tiwari if instead of making root.data=-1 we want to remove the root as root=null,but doesn’t works…how to remove the root instead of making root.data=-1,please help.. Ramya Can you tell me how to return the root of the pruned tree and print the data? Vishnu Vardhan lsum can get overflown. Sumit Monga solution is better. hary Correct me If I am wrong, I believe it does not take into account the fact that the tree can have nodes with -ve data values. Sumit Monga Another solution is: #include #include struct node { int data; struct node *left, *right; }; // A utility function to create a new Binary Tree node with given data struct node* newNode(int data) { struct node* node = (struct node*) malloc(sizeof(struct node)); node->data = data; node->left = node->right = NULL; return node; } void print(struct node *root) { if (root != NULL) { print(root->left); printf(“%d “,root->data); print(root->right); } } struct node * remove_pathsum_less_than_k(struct node * root,int k) { if(root == NULL) return (NULL); if(root->data >= k) return (root); else { struct node * left = remove_pathsum_less_than_k(root->left,k-root->data); struct node * right = remove_pathsum_less_than_k(root->right,k-root->data); root->left = left; root->right = right; if(!left && !right) { free(root); return (NULL); } return (root); } } int main() { int k = 45; struct node *root = newNode(1); root->left = newNode(2); root->right = newNode(3); root->left->left = newNode(4); root->left->right = newNode(5); root->right->left = newNode(6); root->right->right = newNode(7); root->left->left->left = newNode(8); root->left->left->right = newNode(9); root->left->right->left = newNode(12); root->right->right->left = newNode(10); root->right->right->left->right = newNode(11); root->left->left->right->left = newNode(13); root->left->left->right->right = newNode(14); root->left->left->right->right->left = newNode(15); printf(“Tree before truncationn”); print(root); root = remove_pathsum_less_than_k(root, k); // k is 45 printf(“nnTree after truncationn”); print(root); return 0; } piyush Nice solution It’s a famous amazon Interview question Guest A better question could be–remove all nodes which don’t lie in any path with sum>=k GeeksforGeeks Thanks for the suggestion. We have updated the title of the post. Anirban Saha Is it neccessary to find lsum and rsum and find the max ? Is it not sufficient to find only sum ? Am i missing any boundary conditions ? Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
