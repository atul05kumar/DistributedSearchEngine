Time Complexity of building a heap - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph Time Complexity of building a heap Consider the following algorithm for building a Heap of an input array A. 
BUILD-HEAP(A) 
    heapsize := size(A); 
    for i := floor(heapsize/2) downto 1 
        do HEAPIFY(A, i); 
    end for 
END
 What is the worst case time complexity of the above algo? Although the worst case complexity looks like O(nLogn), upper bound of time complexity is O(n). See following links for the proof of time complexity. http://www.cse.iitk.ac.in/users/sbaswana/Courses/ESO211/heap.pdf/ http://www.cs.sfu.ca/CourseCentral/307/petra/2009/SLN_2.pdf           Related Topics: Job Sequencing Problem | Set 1 (Greedy Algorithm) Multiply two polynomials Algorithm Practice Question for Beginners | Set 1 Count Distinct Non-Negative Integer Pairs (x, y) that Satisfy the Inequality x*x + y*y < n Binomial Heap Print all increasing sequences of length k from first n natural numbers Find n’th number in a number system with only 3 and 4 Minimum Cost Polygon Triangulation Tweet Writing code in comment? Please use ideone.com and share the link here. groomnestle It is easier to write heapsort with first heap index as 1 instead of 0, in this case you can correlate parent and children with a simple formula: parent = k, left child = 2k, right child= 2k+1. http://www.linkedin.com/in/ramanawithu Venki The complexity O(n log n) is an upper bound. The upper bound is calculated assuming that every node is of height log n. But in reality it is not the case. Height of node varies in the heap. By definition, height of a node is the longest path length from that node to leaf node. This way the root is at maximum height, followed by next level subtrees. The build-heap time complexity is function of node’s height f(h). How can we express f(h)? Given a binary-heap having N elements, we can observe that there will be maximum of f(h) = [N/2^(h+1)] nodes at height h. For example, given N = 7 i.e. a full binary tree of height 2, the root is at height of 2 and f(2) = 7/8 = 0, f(1) = 7/4 = 1, f(0) = 7/2 = 3, all satisfying our assumption. Infact, it is an approximation and as the height of tree increases our approximation reach exact limit. Now, it is easy to check the tighter bound on building the heap. To build heap, we call heapify() whose complexity is O(h) and we call it on nodes from nodes n/2 to 1. These nodes form internal nodes of binary heap. To find exact computational cost we need to sum the cost of heapifying each node. Yet we are interested in asymptotic bound. We need to find the cost of *a node* at each level and integrate (sum) them to find the complexity. Mathematically T(n) = summation of [h x f(h)] in the interval 0 to logN (i.e. height of tree). After solving the integration, we will arrive at 2N which is linear in N. Hope it helps in better understanding the heap build analysis. The tighter bound is O(n) and upper bound is O(n log n). @Sandeep, little correction required in the post. http://geeksforgeeks.org/ Sandeep @Venki: Both O(n) and O(nLogn) are upper bounds for build heap. O(n) is tighter upper bound. tk Ineresting fact. Good to know. Vinay one conceptual question from Cormen:why the loop goes down from heapsize/2 to 1 and not increment from 1 to heapsize/2? kartik I think its because the way Heapify process works. When we Heapify a node at index i, we assume that all the subtrees of i are heapified. Also, the Heapify process must go in upward direction to make sure that the maximum (or minimum) element is at the top. Amit If you index i=1 to n/2 you can observe that you will need to modify your Heapify function to work (try to apply this and you will able to see the differnece )…. so in Cormen to avoid this modification we start with i=n/2 to 1 Both indexing will work but the efficient way will be the latter case…. Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
