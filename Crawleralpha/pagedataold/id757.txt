Skip List | Set 1 (Introduction) - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph Skip List | Set 1 (Introduction) Can we search in a sorted linked list in better than O(n) time? The worst case search time for a sorted linked list is O(n) as we can only linearly traverse the list and cannot skip nodes while searching. For a Balanced Binary Search Tree, we skip almost half of the nodes after one comparison with root. For a sorted array, we have random access and we can apply Binary Search on arrays. Can we augment sorted linked lists to make the search faster? The answer is Skip List. The idea is simple, we create multiple layers so that we can skip some nodes. See the following example list with 16 nodes and two layers. The upper layer works as an “express lane” which connects only main outer stations, and the lower layer works as a “normal lane” which connects every station. Suppose we want to search for 50, we start from first node of “express lane” and keep moving on “express lane” till we find a node whose next is greater than 50. Once we find such a node (30 is the node in following example) on “express lane”, we move to “normal lane” using pointer from this node, and linearly search for 50 on “normal lane”. In following example, we start from 30 on “normal lane” and with linear search, we find 50. What is the time complexity with two layers? The worst case time complexity is number of nodes on “express lane” plus number of nodes in a segment (A segment is number of “normal lane” nodes between two “express lane” nodes) of “normal lane”. So if we have n nodes on “normal lane”, nodes on “express lane” and we equally divide the “normal lane”, then there will be nodes in every segment of “normal lane” . is actually optimal division with two layers. With this arrangement, the number of nodes traversed for a search will be . Therefore, with extra space, we are able to reduce the time complexity to . Can we do better? The time complexity of skip lists can be reduced further by adding more layers. In fact, the time complexity of search, insert and delete can become O(Logn) in average case. We will soon be publishing more posts on Skip Lists. References MIT Video Lecture on Skip Lists http://en.wikipedia.org/wiki/Skip_list Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.           Related Topics: Given a linked list, reverse alternate nodes and append at the end Pairwise swap elements of a given linked list by changing links Self Organizing List | Set 1 (Introduction) Merge a linked list into another linked list at alternate positions QuickSort on Singly Linked List Delete N nodes after M nodes of a linked list Design a stack with operations on middle element Swap Kth node from beginning with Kth node from end in a Linked List Tweet Writing code in comment? Please use ideone.com and share the link here. Vinay Singh nice stuff…good 2 learn a new datastructure. nigam next post?? when? where? Vsprabhakaran Prabhu This is superb stuff. Though it resembles a bit of indexing technique, who would have thought to implement it as two layers of linked list. tausif akram this is simply awesome !! tripathi http://www.dreamincode.net/forums/blog/114/entry-2727-introduction-to-a-skiplist-data-structure-in-java/ nishant08 awesome ultimate_coder  
@geeksforgeeks Could u post c/c++ code or algo for insertion/deletion in skip list?
It will be highly appreciated ! !
 abhishek08aug Intelligent CODER_1 gr8 and nice tutorial.  
/* Paste your code here (You may delete these lines if not writing code) */
 gh05t Extremely similar to B+ tree..if you relax a few rules followed by a B+ tree it becomes a skip list…Can somebody please point out a fundamental difference?  
/* Paste your code here (You may delete these lines if not writing code) */
 cooldude class Node { int data; Node next; Node(int data,Node next) { this.data=data; this.next=next; } } class SpecialNode extends Node { SpecialNode right; SpecialNode(int data,Node next,SpecialNode right) { super(data,next); this.right=right; } } public int size(Node head) { Node cur=head; int count=0; while(cur!=null) { count++; cur=cur.next; } return count; } //main function public boolean searchInSkipSortedList(Node head,int data) { Node cur=head; int n=size(cur); int i=0; int count=(int) Math.sqrt(n); SpecialNode newNode,prev=null,splHead = null,splCur; while(i<=count+1 && cur!=null) { if(i==count+1 ||prev==null) { newNode=new SpecialNode(cur.data,cur,null); if(prev==null) splHead=newNode; else prev.right=newNode; prev=newNode; i=0; } cur=cur.next; i++; } splCur=splHead; prev=null; while(splCur!=null) { if(splCur.data==data) return true; if(splCur.data>data) break; prev=splCur; splCur=splCur.right; } if(prev==null) return false; Node end; if(splCur==null) end=null; else end=splCur.next; Node start=prev.next; cur=start; while(cur!=end) { if(cur.data==data) return true; cur=cur.next; } return false; } http://www.geeksforgeeks.org/skip-list/# http://www.bitla-srinivas.blogspot.com/ bitlasrinivas fine. ibnipun10 Just wondering how is it different from a BST? Also there is a requirement for linked list to be sorted aayushkumar want awesomee tutorial for B,B+ tree like this ….:) Uddhav Arote How would this be different from the B+ trees which is more or less similar to this … right ? At the leaf level, in B+ trees, the siblings from different parents are connected via a link ..  
/* Paste your code here (You may delete these lines if not writing code) */
 Uddhav ok understood .. nice stuff ! Niks Awesome ….Please provide tutorials on B-trees,AB trees too Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
