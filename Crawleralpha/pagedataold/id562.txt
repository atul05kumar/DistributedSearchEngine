Merge a linked list into another linked list at alternate positions - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph Merge a linked list into another linked list at alternate positions Given two linked lists, insert nodes of second list into first list at alternate positions of first list. For example, if first list is 5->7->17->13->11 and second is 12->10->2->4->6, the first list should become 5->12->7->10->17->2->13->4->11->6 and second list should become empty. The nodes of second list should only be inserted when there are positions available. For example, if the first list is 1->2->3 and second list is 4->5->6->7->8, then first list should become 1->4->2->5->3->6 and second list to 7->8. Use of extra space is not allowed (Not allowed to create additional nodes), i.e., insertion must be done in-place. Expected time complexity is O(n) where n is number of nodes in first list. The idea is to run a loop while there are available positions in first loop and insert nodes of second list by changing pointers. Following is C implementation of this approach. 
// C implementation of above program.
#include <stdio.h>
#include <stdlib.h>

// A nexted list node
struct node
{
    int data;
    struct node *next;
};

/* Function to insert a node at the beginning */
void push(struct node ** head_ref, int new_data)
{
    struct node* new_node = (struct node*) malloc(sizeof(struct node));
    new_node->data  = new_data;
    new_node->next = (*head_ref);
    (*head_ref)  = new_node;
}

/* Utility function to print a singly linked list */
void printList(struct node *head)
{
    struct node *temp = head;
    while (temp != NULL)
    {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Main function that inserts nodes of linked list q into p at alternate
// positions. Since head of first list never changes and head of second list 
// may change, we need single pointer for first list and double pointer for 
// second list.
void merge(struct node *p, struct node **q)
{
     struct node *p_curr = p, *q_curr = *q;
     struct node *p_next, *q_next;

     // While therre are avialable positions in p
     while (p_curr != NULL && q_curr != NULL)
     {
         // Save next pointers
         p_next = p_curr->next;
         q_next = q_curr->next;

         // Make q_curr as next of p_curr
         q_curr->next = p_next;  // Change next pointer of q_curr
         p_curr->next = q_curr;  // Change next pointer of p_curr

         // Update current pointers for next iteration
         p_curr = p_next;
         q_curr = q_next;
    }

    *q = q_curr; // Update head pointer of second list
}

// Driver program to test above functions
int main()
{
     struct node *p = NULL, *q = NULL;
     push(&p, 3);
     push(&p, 2);
     push(&p, 1);
     printf("First Linked List:\n");
     printList(p);

     push(&q, 8);
     push(&q, 7);
     push(&q, 6);
     push(&q, 5);
     push(&q, 4);
     printf("Second Linked List:\n");
     printList(q);

     merge(p, &q);

     printf("Modified First Linked List:\n");
     printList(p);

     printf("Modified Second Linked List:\n");
     printList(q);

     getchar();
     return 0;
}
 Output: First Linked List:
1 2 3
Second Linked List:
4 5 6 7 8
Modified First Linked List:
1 4 2 5 3 6
Modified Second Linked List:
7 8 This article is contributed by Chandra Prakash. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.           Related Topics: Given a linked list, reverse alternate nodes and append at the end Pairwise swap elements of a given linked list by changing links Self Organizing List | Set 1 (Introduction) QuickSort on Singly Linked List Delete N nodes after M nodes of a linked list Design a stack with operations on middle element Swap Kth node from beginning with Kth node from end in a Linked List QuickSort on Doubly Linked List Tweet Writing code in comment? Please use ideone.com and share the link here. Pranav node* mergeAlt(node* p,node* q) { if(p==NULL) return q; if(q==NULL) return p; //1-2-3-4 //6-7-8-9-10 node* temp = p; node* p_prev = p; while(p!=NULL && q!=NULL) { node* p_nxt = p->next; node* q_nxt = q->next; p->next = q; q->next = p_nxt; p_prev = p; p = p_nxt; q = q_nxt; } //if first list is smaller than last list if(p==NULL) { while(q!=NULL) { p_prev->next = q; q=q->next; p_prev = p_prev->next; } } return temp; } Pranav Sawant Apologies for this, please refer the below mentioned code node* mergeAlt(node* p,node* q) { if(p==NULL) return q; if(q==NULL) return p; //1-2-3-4 //6-7-8-9-10 node* temp = p; while(p!=NULL && q!=NULL) { node* p_nxt = p->next; node* q_nxt = q->next; p->next = q; q->next = p_nxt; if(p_nxt==NULL) q->next = q_nxt; p = p_nxt; q = q_nxt; } return temp; } Tarzan This solution does not consider the case where the first list is empty while the second list is not. void merge(struct node **p, struct node **q){ if(*p==NULL){ *p = *q; return; } Pranav node* mergeAlt(node* p,node* q) { if(p==NULL) return q; if(q==NULL) return p; //1-2-3-4 //6-7-8-9-10 node* temp = p; node* p_prev = p; while(p!=NULL && q!=NULL) { node* p_nxt = p->next; node* q_nxt = q->next; p->next = q; q->next = p_nxt; if(p_nxt==NULL) q->next = q_nxt; //p_prev = q->next; p = p_nxt; q = q_nxt; } return temp; } jim302 Above program fails when first list has less node than second list. Example: firstlist:1->2->NULL secondlist: 11->12->13->14->NULL Please check once. Kunal Arora Simple Implementation with O(1) space complexity…….. Please suggest me if you find some fault void merge(struct node *head,struct node **root) { struct node *p=head,*q,*t=(*root); while(p) { if(t!=NULL) { q=t; t=t->next; q->next=p->next; p->next=q; } p=p->next->next; } *root=t; } Abhilash Kumar in the solution given above the header value of q is updated . is it necessary to do this . Anand /*Merge a linked list into another linked list at alternate positions*/ #include #include #include struct l { int data; struct l *link; }; void add(struct l **,int ); void merge(struct l**,struct l **); void display(struct l*); int main() { struct l *r2,*r1; r1 = NULL; add(&r1,1); add(&r1,2); add(&r1,3); add(&r1,4); add(&r1,5); add(&r1,6); r2 = NULL; add(&r2,11); add(&r2,22); add(&r2,33); add(&r2,44); add(&r2,55); add(&r2,66); merge(&r1,&r2); display(r1); getch(); return 1; } void add(struct l** u,int data) { struct l *temp; if(*u == NULL) { *u = (struct l*)malloc(sizeof(struct l)); (*u)->data = data; (*u)->link = NULL; } else { temp = *u; while(temp->link!=NULL) temp = temp->link; temp->link = (struct l*)malloc(sizeof(struct l)); temp = temp->link; temp->data = data; temp->link = NULL; } } void display(struct l* u) { while(u!=NULL) { printf(“%d “,u->data); u = u->link; } } void merge(struct l** l1,struct l** l2) { struct l *t1,*t2,*s; s = (*l1); while((*l1)->link!=NULL && (*l2)->link!=NULL) { t1 = (*l1)->link; t2 = (*l2)->link; (*l1)->link = (*l2); (*l2)->link = t1; (*l1) = t1; (*l2) = t2; } if((*l2)->link!=NULL) { (*l1)->link = (*l2); } (*l1) = s; } yogeshgfg struct node* mergeAlternative ( struct node* start1, struct node* start2 ) { if(( start1 == NULL)||(start2 == NULL) ) { return start1; } else{ struct node* temp = start1->next; start1->next = start2; mergeAlternative(start2,temp); return start1; } } Ravindra Patidar #include #include struct node { struct node *next; int data; }; struct node *newnode(int data) { struct node *newnode=(struct node *)malloc(sizeof(struct node)); newnode->next=NULL; newnode->data=data; } int main() { struct node *start1,*start2,*temp,*temp2,*temp3,*temp4; int l1=0,l2=0,i,k; start1=newnode(1); start1->next=newnode(2); start1->next->next=newnode(3); start2=newnode(4); start2->next=newnode(5); start2->next->next=newnode(6); start2->next->next->next=newnode(7); temp=start1; while(temp) { l1++; temp=temp->next; } temp=start2; while(temp) { l2++; temp=temp->next; } if(l1>l2) k=l2; else k=l1; i=0; temp3=start1; while(inext; temp4=start2->next; start1->next=start2; start2->next=temp2; start1=temp2; start2=temp4; i++; } printf(“nMERGE LIST IS:”); while(temp3) { printf(“%d”,temp3->data); temp3=temp3->next; } printf(“nSECOND LIST:”); while(start2) { printf(“%d”,start2->data); start2=start2->next; } return 0; } Shalvi Here is my code (Recursive way) – #include using namespace std; struct node { int data; struct node* next; }; void createNode(int data, node** start) { node* temp=new node(); temp->data=data; temp->next=NULL; if(*start==NULL) { *start=temp; } else { node *t=*start; while(t->next!=NULL) { t=t->next; } t->next=temp; } } void print(node* start) { node* temp=start; while(temp!=NULL) { cout<data<next; } } node* mergeList(node * headA, node * headB) { if((headB)==NULL) { return headA; } else if((headA)==NULL) { return headB; } else { node* tA=headA->next; node* tB=headB->next; headA->next=headB; headA->next->next=mergeList(tA,tB); return headA; } } int main() { node * headA=NULL, *headB=NULL; //creating list 1 createNode(5,&headA); createNode(7,&headA); createNode(17,&headA); createNode(13,&headA); createNode(11,&headA); //Creating list 2 createNode(12,&headB); createNode(10,&headB); createNode(2,&headB); createNode(4,&headB); createNode(6,&headB); //Merging List 1 and List 2 headA=mergeList(headA,headB); //Printing modified list print(headA); return 0; } Harsha Shetty Here’s my code.. Seems to be working well … public static void mergeSecondToFirst(SLinkedList list1, SLinkedList list2) { Node first = list1.getHead(); Node firstPrev = list1.getHead(); Node second = list2.getHead(); while(first != null) { firstPrev = first; first = first.getNext(); if(second != null) { firstPrev.setNext(second); second = second.getNext(); firstPrev.getNext().setNext(first); } } list2.setHead(second); } mrigank #include struct node { int data; struct node *next; }; void insert(struct node **,int); struct node* alloc(int); void displayfirst(struct node*); void displaysecond(struct node*); void merge(struct node**, struct node**); int main() { int m,n; struct node *head1,*head2; head1=NULL; head2=NULL; insert(&head1,1); insert(&head1,2); insert(&head1,3); displayfirst(head1); insert(&head2,4); insert(&head2,5); insert(&head2,6); insert(&head2,7); insert(&head2,8); displaysecond(head2); merge(&head1,&head2); displayfirst(head1); displaysecond(head2); //scanf(“%d”,&n); } void insert(struct node **h1, int n) { struct node *temp, *save; temp=NULL; // save=NULL; // if(*h1==NULL) { temp=alloc(n); *h1=temp; } else { save=*h1; while(save->next!=NULL) save=save->next; temp=alloc(n); save->next=temp; } } struct node* alloc(int n) { struct node *temp; temp=malloc(sizeof(struct node)); temp->data=n; temp->next=NULL; return temp; } void displayfirst(struct node *head1) { struct node *save,*save2; save=head1; printf(“nnFirst link list isn”); if(head1==NULL) { printf(“nnEmptynn”); } else{ while(save!=NULL) { printf(“%d-> “,save->data); save=save->next; } } } void displaysecond(struct node *head2) { struct node*save2; save2=head2; printf(“nnSecond link list isn”); if(head2==NULL) { printf(“Emptynn”); } else{ while(save2!=NULL) { printf(“%d-> “,save2->data); save2=save2->next; } } } void merge(struct node **h1,struct node **h2) { struct node *s1=NULL, *s2=NULL,*temp=NULL; s1=*h1; s2=*h2; temp=s2->next; while(temp!=NULL && s1!=NULL) { //*h2=*h2->next; temp=s2->next; s2->next=s1->next; s1->next=s2; s1=s1->next->next; *h2=temp; s2=*h2; } } Guest #include #include //Author-Vikas //Note-We are appending new elements at the end using namespace std; struct node { node *next; int data; }; void traverse(node *); void merge(node *,node **); void insert(node **,int ); //Driver method to test the programme int main() { node *root1=NULL,*root2=NULL; int x; cout<<endl<<"Data for first Linked list"<<endl; insert(&root1,92); cout<<endl<<"Here is your first linked list"; traverse(root1); cout<<endl<<"Data for second linked list"<<endl; insert(&root2,546); insert(&root2,5); insert(&root2,78); insert(&root2,7); insert(&root2,90); cout<<endl<<"Here is your second linked list"; traverse(root2); merge(root1,&root2); cout<<endl<next=NULL; tmp->data=x; *p=tmp; }//endif else insert(&((*p)->next),x); }//end insert //just to show the elements of the linked list void traverse(node *p) { if(p!=NULL) { cout<<endl<data; traverse(p->next); }//end if }//end traverse void merge(node *a,node **p) { static node **start=p; node *b=*p; if(a!=NULL && b!=NULL) { node *a1=a->next; node *b1=b->next; //This is when both the linked list are of equal lenths if(a1==NULL && b1==NULL) { a->next=b; *start=NULL; }//end if //This is when first linked list is greater than that of second //right if(a1!=NULL && b1==NULL) { a->next=b; b->next=a1; *start=NULL; }//END IF //This is when second linked list is greater than first else if(a1==NULL && b1!=NULL) { a->next=b; b->next=NULL; *start = b1; } else { a->next=b; b->next=a1; //recursive call merge(a1,&b1); }//END ELSE }//ENDif }//end merge Guest //Try the recursive solution #include #include //Author-Vikas //Note-We are appending new elements at the end using namespace std; struct node { node *next; int data; }; void traverse(node *); void merge(node *,node **); void insert(node **,int ); //Driver method to test the programme int main() { node *root1=NULL,*root2=NULL; int x; cout<<endl<<"Data for first Linked list"<<endl; insert(&root1,92); cout<<endl<<"Here is your first linked list"; traverse(root1); cout<<endl<<"Data for second linked list"<<endl; insert(&root2,546); insert(&root2,5); insert(&root2,78); insert(&root2,7); insert(&root2,90); cout<<endl<<"Here is your second linked list"; traverse(root2); merge(root1,&root2); cout<<endl<next=NULL; tmp->data=x; *p=tmp; }//endif else insert(&((*p)->next),x); }//end insert //just to show the elements of the linked list void traverse(node *p) { if(p!=NULL) { cout<<endl<data; traverse(p->next); }//end if }//end traverse void merge(node *a,node **p) { static node **start=p; node *b=*p; if(a!=NULL && b!=NULL) { node *a1=a->next; node *b1=b->next; //This is when both the linked list are of equal lenths if(a1==NULL && b1==NULL) { a->next=b; *start=NULL; }//end if //This is when first linked list is greater than that of second //right if(a1!=NULL && b1==NULL) { a->next=b; b->next=a1; *start=NULL; }//END IF //This is when second linked list is greater than first else if(a1==NULL && b1!=NULL) { a->next=b; b->next=NULL; *start = b1; } else { a->next=b; b->next=a1; //recursive call merge(a1,&b1); }//END ELSE }//ENDif }//end merge Raunak Lakhwani class Node { int data; Node next; } public class Main { static Node headFirst, headSecond; /** * @param args */ public static void main(String[] args) { // 1st Test Case headFirst = new Node(); headFirst.data = 5; headFirst.next = new Node(); headFirst.next.data = 7; headFirst.next.next = new Node(); headFirst.next.next.data = 17; headFirst.next.next.next = new Node(); headFirst.next.next.next.data = 13; headFirst.next.next.next.next = new Node(); headFirst.next.next.next.next.data = 11; headSecond = new Node(); headSecond.data = 12; headSecond.next = new Node(); headSecond.next.data = 10; headSecond.next.next = new Node(); headSecond.next.next.data = 2; headSecond.next.next.next = new Node(); headSecond.next.next.next.data = 4; headSecond.next.next.next.next = new Node(); headSecond.next.next.next.next.data = 6; // 2nd Test Case /* * headFirst = new Node(); headFirst.data = 5; headFirst.next = new * Node(); headFirst.next.data = 7; headFirst.next.next = new Node(); * headFirst.next.next.data = 17; headFirst.next.next.next = new Node(); * headFirst.next.next.next.data = 13; headFirst.next.next.next.next = * new Node(); headFirst.next.next.next.next.data = 11; * * headSecond = new Node(); headSecond.data = 12; headSecond.next = new * Node(); headSecond.next.data = 10; headSecond.next.next = new Node(); * headSecond.next.next.data = 2; */ // 3rd Test Case /* * headFirst = new Node(); headFirst.data = 5; headFirst.next = new * Node(); headFirst.next.data = 7; headFirst.next.next = new Node(); * headFirst.next.next.data = 17; * * headSecond = new Node(); headSecond.data = 12; headSecond.next = new * Node(); headSecond.next.data = 10; headSecond.next.next = new Node(); * headSecond.next.next.data = 2; headSecond.next.next.next = new * Node(); headSecond.next.next.next.data = 4; * headSecond.next.next.next.next = new Node(); * headSecond.next.next.next.next.data = 6; */ merge(); while (headFirst != null) { System.out.print(headFirst.data + ” “); headFirst = headFirst.next; } System.out.println(); while (headSecond != null) { System.out.print(headSecond.data + ” “); headSecond = headSecond.next; } } public static void merge() { Node startFirst = headFirst; while (startFirst != null && headSecond != null) { Node startFirstTemp = startFirst.next; Node startSecondTemp = headSecond.next; startFirst.next = headSecond; headSecond.next = startFirstTemp; headSecond = startSecondTemp; startFirst = startFirstTemp; } } } Uma Trika void merge(node *first, node *second) { node *temp_first = first; node *temp_second = *second; node *temp_1, *temp_2; while(temp_first && temp_second) { temp_1 = temp_first->next; temp_2 = temp_second->next; temp_first->next = temp_second; temp_first = temp_first->next; temp_first->next = temp_1; temp_second = temp_2; if(temp_1) temp_first = temp_1; } if(temp_2) temp_first->next = temp_2; else temp_first->next = NULL; } discent Below Will print first Linked List as Merged linked List and second list as NULL if both are of equal length or second linked list is of smaller length else rest of the second list will be printed : #include using namespace std; class AlternateMergedList{ private: struct node{ int data; struct node *next; }; node *firstHead; node *secHead; node *newNode; node *firstCurrent; node *secCurrent; node **listPointer; public: void createList( int ); void mergeList( ); void display(); AlternateMergedList(){ firstHead = NULL; secHead = NULL; firstCurrent = NULL; secCurrent = NULL; listPointer = NULL; } }; void AlternateMergedList::display(){ firstCurrent = firstHead; while( NULL != firstCurrent ){ cout<data<“; firstCurrent = firstCurrent->next; } cout<<"NULL"<<endl; secCurrent = secHead; while( NULL != secCurrent ){ cout<data<“; secCurrent = secCurrent->next; } cout<<"NULL"<next; temp2 = secCurrent->next; firstCurrent->next = secCurrent; secCurrent->next = temp1; firstCurrent = temp1; secCurrent = temp2; secHead = secCurrent; 1,1 Top } } void AlternateMergedList::createList( int listNum ){ int item = 0; if( 0 == listNum ){ if( NULL == firstHead ){ listPointer = &firstCurrent; cout<<"Enter First List items. To terminate input, enter -1"<<endl; } } else if ( 1 == listNum ){ if( NULL == secHead ){ listPointer = &secCurrent; cout<<"Enter Second List items. To terminate input, enter -1"<>item; if( -1 != item ) { if ( NULL == *listPointer ){ newNode = new node; newNode->data = item; if( 0 == listNum ) firstHead = newNode; else secHead = newNode; *listPointer = newNode; } else{ newNode = new node; newNode->data = item; (*listPointer)->next = newNode; *listPointer = newNode; } newNode->next = NULL; createList( listNum ); } listPointer = NULL; } int main(){ AlternateMergedList list; list.createList( 0 ); list.createList( 1 ); list.mergeList(); list.display(); return 0; } tarun void merge(struct node *head1,struct node **head2Ref) { struct node *temp2=*head2Ref; while(head1!=NULL && *head2Ref!=NULL) { *head2Ref=temp2->next; temp2->next=head1->next; head1->next=temp2; head1=head1->next->next; temp2=head2; } } Debojit Choudhury public class LinkedListProblem2 { public static void main(String[] args) { Node headerNode1 = new Node(1, createLinkedList(7, 1)); Node headerNode2 = new Node(8, createLinkedList(3, 8)); display(headerNode1, headerNode2); headerNode2 = insertLinkedList2Into1(headerNode1, headerNode2); display(headerNode1, headerNode2); } private static Node createLinkedList(int numberOfNodes, int startingNode) { int data = numberOfNodes + startingNode – 1; Node node = new Node(data, null); for (int i = data – 1; i > startingNode; i–) { Node previousNode = new Node(i, node); node = previousNode; } return node; } private static void display(Node… nodes) { int i = 1; for (Node headerNode : nodes) { display(headerNode, “List” + i + “: “); i++; } } private static void display(Node headerNode, String listName) { System.out.print(listName); if (headerNode == null) { return; } while (headerNode.nextNode != null) { System.out.print(headerNode.data + “->”); headerNode = headerNode.nextNode; } System.out.println(headerNode.data); } private static Node insertLinkedList2Into1(Node headerNode1, Node headerNode2) { if (headerNode1 == null || headerNode2 == null) { return headerNode2; } Node tempNode1 = headerNode1.nextNode; Node tempNode2 = headerNode2.nextNode; headerNode1.nextNode = headerNode2; headerNode2.nextNode = tempNode1; return insertLinkedList2Into1(tempNode1, tempNode2); } private static class Node { private int data; private Node nextNode; private Node(int data, Node nextNode) { this.data = data; this.nextNode = nextNode; } } } sk I see that new nodes are created. But no new nodes should be created, right? Monty It will work correctly for any size of arrays. void merge(struct node **i, struct node **j) { struct node *k, *l, *m=*i; while((*i)->next!=NULL && (*j)->next!=NULL) { k=(*i)->next; (*i)->next=(*j); l=(*j)->next; (*j)->next=k; (*i)=k; (*j)=l; } if((*i)->next==NULL) { (*i)->next=(*j); k=(*j)->next; (*j)->next=NULL; } else if((*j)->next==NULL) { k=(*i)->next; (*i)->next=(*j); } else return; cout<<"Merged list: "; display(m); cout<<"Remaining list: "; display(k); } Guest I think this will work correctly- #include using namespace std; void display(struct node*); struct node { int data; struct node *next; }; void merge(struct node **i, struct node **j) { struct node *k, *l, *m=*i; while((*i)->next!=NULL && (*j)->next!=NULL) { k=(*i)->next; (*i)->next=(*j); l=(*j)->next; (*j)->next=k; (*i)=k; (*j)=l; } if((*i)->next==NULL) { (*i)->next=(*j); k=(*j)->next; (*j)->next=NULL; } else if((*j)->next==NULL) { k=(*i)->next; (*i)->next=(*j); } else return; cout<<"Merged list: "; display(m); cout<data=val; p->next=NULL; if(*ptr==NULL) *ptr=p; else{ while((*ptr)->next!=NULL) *ptr=(*ptr)->next; (*ptr)->next=p; *ptr=q; } } void display(struct node *ptr) { while(ptr!=NULL) { cout<<" |"<data<next; } cout<<endl; } int main() { int num1, num2, val; struct node *ptr1=NULL, *ptr2=NULL; cout<<"Enter the number of element in the 1st list "<>num1; for(int i=0; i<num1 ; i++) { cout<>val; insert(&ptr1, val); } display(ptr1); cout<<"Enter the number of element in the 2nd list "<>num2; for(int i=0; i<num2 ; i++) { cout<>val; insert(&ptr2, val); } display(ptr2); merge(&ptr1, &ptr2); system("pause"); } Monty The program will not give correct output if list one is grater then list two. Progs hey what if LinkedList B is larger it is should be merge with first one or nop? naveen shukla Recursive implementation void merge( struct node *head1, struct node **head2 ) { if ( head1 == NULL || *head2 == NULL ) { return; } struct node *temp = head1->next; head1->next = *head2; *head2 = (*head2)->next; head1->next->next = temp; merge(temp,head2); } Guest node* join_ll(node *s1,node *s2) { node *p,*q,*t1=s1; p=s1; q=s2; while(t1!=NULL) { if(p!=NULL) { t1=p->next; p->next=q; p=t1; t1=q->next; q->next=p; q=t1; } else break; } return q; } Guest node* join_ll(node *s1,node *s2) { node *p,*q,*t1=s1; p=s1; q=s2; while(t1!=NULL) { if(p!=NULL) { t1=p->next; p->next=q; p=t1; t1=q->next; q->next=p; q=t1; } else break; } return q; } saurabh verma #include #include #include #include struct node { int data; struct node *next; }; typedef struct node node; node *create_ll() { node *t,*p,*s=NULL; do{ p=t; t=(node*)malloc(sizeof(node)); printf("enter datan"); scanf("%d",&t->data); t->next=NULL; if(s==NULL) { s=t; } else { p->next=t; } printf("do u want to continue y/nn"); }while('y'==getch()); return s; } void print(node *s) { printf("----------------------LINKLIST---------------------n"); while(s!=NULL) { printf("%dt",s->data); s=s->next; } } node* reverse(node *s) { node *p=s,*q=s; p=s->next; q=p->next; s->next=NULL; while(p!=NULL) { p->next=s; s=p; p=q; if(q!=NULL) q=q->next; } return s; } node* join_ll(node *s1,node *s2) { node *p,*q,*t1=s1; p=s1; q=s2; while(t1!=NULL) { if(p!=NULL) { t1=p->next; p->next=q; p=t1; t1=q->next; q->next=p; q=t1; } else break; } return q; } void main() { int a; char c; node *s1=NULL,*s2=NULL; int k; clrscr(); do{ printf("npress 1 to create_lln"); printf("press 2 to create_ll2n"); printf("press 3 to print_ll1n"); printf("press 4 to print_ll2n"); printf("press 5 to reverse1n"); printf("press 6 to reverse2n"); printf("press 7 to join_lln"); printf("press 8 to exitn"); scanf("%d",&a); switch(a) { case 1: s1=create_ll(); break; case 2: s2=create_ll(); break; case 3: print(s1); break; case 4: print(s2); break; case 5: s1=reverse(s1); break; case 6: s2=reverse(s2); break; case 7: s2=join_ll(s1,s2); break; case 8: exit(1); default: printf("wrong choicen"); } }while(1); } Chandu void merge(struct node *p, struct node **q) { struct node *q_prev=NULL; while(p!=NULL && (*q)!=NULL) { q_prev = *q; *q = (*q)->next; q_prev->next = p->next; p->next = q_prev; p = p->next->next; } } // Working for all the corner cases. Uses only one extra node pointer suhas meena i was trying to do this with just two pointers but could not find solution  
/* Paste your code here (You may delete these lines if not writing code) */
 panda  
/* Paste your code here (You may delete these lines if not writing code) */
 #include #include struct node { int data; struct node *next; }; struct node *create(struct node *,int ); struct node *change(struct node *,struct node *); int main() { struct node *head1=NULL,*head2=NULL,*p; int n1,n2; scanf(“%d%d”,&n1,&n2); head1=create(head1,n1); head2=create(head2,n2); head2=change(head1,head2); p=head1; while(p!=NULL) { printf(“%3d”,p->data); p=p->next; } printf(“\n”); p=head2; while(p!=NULL) { printf(“%3d”,p->data); p=p->next; } return 0; } struct node *create(struct node *head,int n) { int i,v; struct node *temp,*p; for(i=0;idata=v; temp->next=NULL; if(head==NULL) head=temp; else { p=head; while(p->next!=NULL) p=p->next; p->next=temp; } } return head; } struct node *change(struct node *p1,struct node *p2) { struct node *r,*q; while(p1->next!=NULL) { if(p2==NULL) return p2; q=p1->next; r=p2->next; p1->next=p2; p2->next=q; p1=p1->next->next; p2=r; } r=p2->next; p1->next=p2; p2->next=NULL; return r; } Saurabh While should condition should be p_curr!=NULL && q_curr!=NULL GeeksforGeeks Thanks for pointing this out. We have updated the code. Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
