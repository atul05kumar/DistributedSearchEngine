A Time Complexity Question - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph A Time Complexity Question What is the time complexity of following function fun()? Assume that log(x) returns log value in base 2. 
void fun()
{
   int i, j;
   for (i=1; i<=n; i++)
      for (j=1; j<=log(i); j++)
         printf("GeeksforGeeks");
}
 Time Complexity of the above function can be written as which is Order of growth of and is same for large values of , i.e., . So time complexity of fun() is . The expression can be easily derived from following Stirling’s approximation (or Stirling’s formula). Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. Sources: http://en.wikipedia.org/wiki/Stirling%27s_approximation           Related Topics: Job Sequencing Problem | Set 1 (Greedy Algorithm) Multiply two polynomials Algorithm Practice Question for Beginners | Set 1 Count Distinct Non-Negative Integer Pairs (x, y) that Satisfy the Inequality x*x + y*y < n Binomial Heap Print all increasing sequences of length k from first n natural numbers Find n’th number in a number system with only 3 and 4 Minimum Cost Polygon Triangulation Tweet Writing code in comment? Please use ideone.com and share the link here. Devesh_D One more reason is there for use of quick sort more than merge sort because merge sort complexity is fixed in all the cases (best , avg, worst) that means it is not depend on the input type(like sorted or unsorted etc).And in case of quick sort if we are using randomized quick sort then we are sure that there is no worst case situation will occur. and the time taken by the quick sort is always less than or equal to merge sort. Prince Yes harsh, correct..n! ‘s upper bound is n^n so will beome nlogn. shash But here they are using Theta notation,but you have used Big-oh notation? Mihir I might be wrong, but we do not know anything about the complexity of the function that calculates the log value here. How can we comment about the overall complexity without knowing this? (Unless it is a library function of known complexity. Then it is fine.) Nidhi Shouldn’t we consider the first loop “i” while calculating complexity ?  
/* Paste your code here (You may delete these lines if not writing code) */
 neha2210 We are indeed considering the first loop also that is why we are adding up theta(log 1)+theta(log 2)… As you see if both loops are repeated for n times then the complexity would be n+n+n…n times i.e n2. We do it here in a similar manner. vivek Does it mean that the given code is as effficient as following code?  void fun()
{
   int i, j;
   for (i=1; i<=n; i++)
      for (j=1; j<=log(n); j++) 
        printf("GeeksforGeeks");
} http://geeksforgeeks.org/ Sandeep @vivek: Both codes are of same time complexity as both are asymptotically same, but code given by you will take more time in general. As an example, both 2n and 10000n are of same time complexity O(n), but a code that takes 10000n time will definiely take more time. What we conclude from this is Asymptotic analysis is not perfect, but it is the only availavle way to compare algorithms irrespective of different computing powers, architectures.. etc. As another example, we can consider Merge Sort and Quick Sort. Although, worst case complexity of Quick Sort is more and average case is same as Merge Sort. Quick Sort is preferred because of the hidden greater constants in Merge Sort. Doom @Sandeep: Could you please tell me more about the hidden greater constants in Merge Sort – the reason why we prefer quick sort over mergesort? http://geeksforgeeks.org/ Sandeep @Doom: These constants are not fixed and vary from machine to machine. All we can say is that the constants for MergeSort are greater than QuickSort in general. Doom @Sandeep: But what are these constants related to? I mean what exactly are u trying to point out? is it like the no. of comparisons involved? or is it like the data movement in the array? plz give some examples about the constants. http://geeksforgeeks.org/ Sandeep @Doom: These constants are greater if number of CPU cycles involved in loop or recursion are more. The CPU cycles might be used for things like data comparisons, data movement etc. For example, consider the following two loops. Time complexity of both of them is O(n), but the constants involved in Loop 2 are more than Loop 1 and these constants vary from machine to machine.  
// Loop 1
for(i = 0; i < n; i++)
{
}

// Loop 2
for(i = 0; i < n; i++)
{
    printf("GeeksforGeeks");
} Hope I made things clear this time. Amit @Doom: These constants depends upon cost of executing instructions on the specific machine…. Like some machine incurs more cost in assignment than other machine…. Doom @Amit: yes, you are right. But discussing about the architecture is a different thing. I am more concerned about the specific instructions which make make mergesort an expensive operation than quick sort. viresh mergesort is not inPlace.. so each time u ask for a extra space in the merge function there might be a page fault and also mergesort involves too many assignments that makes mergesort costlier.. in contrast quicksort is inplace and quicksort deals with changing the index rather than swapping the elements in each inner loop(avg case swaps 2s in d inner loop).. Bhagat Vishal what i think , in case of deciding priority between the merge sort and quick sort is the extra ammount of space taken by merge sort .but this could be avoided by implementing it through linked list without any extra space. Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
