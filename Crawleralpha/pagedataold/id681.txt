Check if all leaves are at same level - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph Check if all leaves are at same level Given a Binary Tree, check if all leaves are at same level or not. 
          12
        /    \
      5       7       
    /          \ 
   3            1
  Leaves are at same level

          12
        /    \
      5       7       
    /          
   3          
   Leaves are Not at same level


          12
        /    
      5             
    /   \        
   3     9
  /      /
 1      2
 Leaves are at same level
 We strongly recommend you to minimize the browser and try this yourself first. The idea is to first find level of the leftmost leaf and store it in a variable leafLevel. Then compare level of all other leaves with leafLevel, if same, return true, else return false. We traverse the given Binary Tree in Preorder fashion. An argument leaflevel is passed to all calls. The value of leafLevel is initialized as 0 to indicate that the first leaf is not yet seen yet. The value is updated when we find first leaf. Level of subsequent leaves (in preorder) is compared with leafLevel. 
// C program to check if all leaves are at same level
#include <stdio.h>
#include <stdlib.h>

// A binary tree node
struct Node
{
    int data;
    struct Node *left, *right;
};

// A utility function to allocate a new tree node
struct Node* newNode(int data)
{
    struct Node* node = (struct Node*) malloc(sizeof(struct Node));
    node->data = data;
    node->left = node->right = NULL;
    return node;
}

/* Recursive function which checks whether all leaves are at same level */
bool checkUtil(struct Node *root, int level, int *leafLevel)
{
    // Base case
    if (root == NULL)  return true;

    // If a leaf node is encountered
    if (root->left == NULL && root->right == NULL)
    {
        // When a leaf node is found first time
        if (*leafLevel == 0)
        {
            *leafLevel = level; // Set first found leaf's level
            return true;
        }

        // If this is not first leaf node, compare its level with
        // first leaf's level
        return (level == *leafLevel);
    }

    // If this node is not leaf, recursively check left and right subtrees
    return checkUtil(root->left, level+1, leafLevel) &&
           checkUtil(root->right, level+1, leafLevel);
}

/* The main function to check if all leafs are at same level.
   It mainly uses checkUtil() */
bool check(struct Node *root)
{
   int level = 0, leafLevel = 0;
   return checkUtil(root, level, &leafLevel);
}

// Driver program to test above function
int main()
{
    // Let us create tree shown in thirdt example
    struct Node *root = newNode(12);
    root->left = newNode(5);
    root->left->left = newNode(3);
    root->left->right = newNode(9);
    root->left->left->left = newNode(1);
    root->left->right->left = newNode(1);
    if (check(root))
        printf("Leaves are at same level\n");
    else
        printf("Leaves are not at same level\n");
    getchar();
    return 0;
}
 Output: Leaves are at same level Time Complexity: The function does a simple traversal of the tree, so the complexity is O(n). This article is contributed by Chandra Prakash. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.           Related Topics: Perfect Binary Tree Specific Level Order Traversal Print Nodes in Top View of Binary Tree K Dimensional Tree Convert a Binary Tree to Threaded binary tree Serialize and Deserialize an N-ary Tree Serialize and Deserialize a Binary Tree Print nodes between two given level numbers of a binary tree Find Height of Binary Tree represented by Parent array Tweet Writing code in comment? Please use ideone.com and share the link here. GeeksforGeeks @All, thanks for sharing your thoughts. We have removed the second method as it was not handling all cases. The first method seems to be simple and handles all cases. Isha This will work: int checkLeavesLevel(struct Node *root) { if(root->left==NULL && root->right==NULL) return 1; if(root->left!=NULL && root->right!=NULL) { int lh=checkLeavesLevel(root->left); int rh=checkLeavesLevel(root->right); if(lh==-1 || rh==-1) return -1; if(lh==rh) { return lh+1; } return -1; } else if(root->left==NULL && root->right!=NULL) { int rh=checkLeavesLevel(root->right); if(rh==-1) return -1; return rh+1; } else if(root->left!=NULL && root->right==NULL) { int lh=checkLeavesLevel(root->left); if(lh==-1) return -1; return lh+1; } } int main() { struct Node *root = newNode(12); root->left = newNode(5); root->right = newNode(7); root->left->left = newNode(3); root->right->right = newNode(1); root->right->left = newNode(2); if (checkLeavesLevel(root)!=-1) printf(“Leaves are at same leveln”); else printf(“Leaves are not at same leveln”); return 0; } Isha The second method is giving incorrect results for the given tree: struct Node *root = newNode(12); root->left = newNode(5); root->right = newNode(7); root->left->left = newNode(3); root->right->right = newNode(1); root->right->left = newNode(2) The o/p should be: Leaves are at same level Setu We can use this java method to check the leaf nodes, if output is -1, leaf nodes are not at same level , other wise it is. public static int utilMethod(Node root, int height) { if(root==null) return height; else if(root.left==null && root.right==null) return height; else if(root.left==null) return utilMethod(root.right, height+1); else if(root.right==null) return utilMethod(root.left, height+1); int leftHeight = utilMethod(root.left, height+1); int rightHeight = utilMethod(root.right, height+1); if(leftHeight==-1 || rightHeight==-1) return -1; else if(leftHeight==rightHeight) return leftHeight; else return -1; } Uma Trika void checkUtil(struct Node *root, int h, int *max) { if(root == NULL) return ; if((*max==0) && (root->left == NULL) && (root->right == NULL)) *max = h; if(root->left == NULL && root->right == NULL && *max != h) { *max = 0; return; } checkUtil(root->left, h+1, max); checkUtil(root->right, h+1, max); } int check(struct Node *root) { int max=0; checkUtil(root, 0, &max); printf(“max val is:%dn”, max); return max; } trojansmith This is a java implementation..plz verify public class Tree { int data; Tree left; Tree right; boolean isSameLevel=true; Tree(int data,Tree left,Tree right){ this.data = data; this.left = left; this.right = right; } public int sameLevel(Tree node,int level,Integer prevMaxLevel){ if(node.left==null && node.right==null){ if(prevMaxLevel!=level && prevMaxLevel==0){ prevMaxLevel=level; }else if(prevMaxLevel != level && prevMaxLevel!=0){ isSameLevel=false; } } if(node.left!=null)prevMaxLevel=sameLevel(node.left,level+1,prevMaxLevel); if(node.right!=null)prevMaxLevel=sameLevel(node.right,level+1,prevMaxLevel); return prevMaxLevel; } public static void main(String[] args){ Tree node1 = new Tree(1,null,null); Tree node3 = new Tree(3,node1,null); Tree node2 = new Tree(2,null,null); Tree node9 = new Tree(9,null,null); Tree node5 = new Tree(5,node3,node9); //Tree node7 = new Tree(7,null,node1); Tree root = new Tree(12,node5,null); root.sameLevel(root,1,0); System.out.println(root.isSameLevel); } } ATul Second Solution is only checking whether the Binary Tree is Full Binary Tree . Pushkar Yeah you are right… it will not work for the given problem.. anonymous plz verify the code boolean traversal(root,int level,int height) { if((root->left==NULL)&&(root->right==NULL)&&(height=level)) return true; else return false; return traversal(root->left,level+1,height)&&traversal(root->right,level+1,height) } anonymous The solution by Very Vibhu tiwari will not result the same result as returned by Chandra prakash,’s solution. Chandra’s solution returns whether all leaf nodes are at the sane level it not. And thus will return true for a tree with root and one leaf node. Say, 100->70 However vibhu’s solution returns whether the tree is a completely balanced tree or not, I.e. all leaves are there and they are at the same level. Thus, it will return false for the root->left node example Dinesh Domma Calculate the height of the tree and the number of nodes which can be done in one recursive traversal. Check the property for the complete binary tree.if it satisfies then all the leaves are at the same level Bharath Just find the min and max heights of the tree and check if they are equal…. din guys,will my code work in all cases??pls validate me….thnx din boolean leavesAtSameLevel(){ int x=-1; int y = 0; int level = 0; Node temp = root; Queue q = new LinkedList; q.enqueue(temp); q.enquue(null); while(!q.isempty()){ temp = q.dequeue; if(temp==null){ if(!q.isempty()){ q.enqueue(null); } level++ } else{ if(temp.left==null && temp.right==null){ // check for first leaf if(x==-1){ y = level; x++; } } if(temp.left!=null){ q.enqueue(temp.left); } if(temp.rightt!=null){ q.enqueue(temp.right); } } if(y==level-1){ return true; } else{ return false; } } din i mean comparing the level of first leaf and the last leaf….using level order traversal..Correct me if i am wrong .Thnx.. din is it enough to check the first leaf and the last leaf using level order traversal?? chetan zaveri Swipe Slate Tablet is Marvelous! Swipe Team definitely comes up with new Innovative Tabs which are just breathe takingJ. Will definitely go for one Vivek bool check_leaves_level(b_tree *root) { if(find_height(root->left) == find_height(root->right) || !root) return true ; else if(find_height(root->left)==0) check_leaves_level(root->right); else if(find_height(root->right)==0) check_leaves_level(root->left); else return false; } Sanjay Agarwal Implementation of the same in C++(Complete Code) #include #include #include using namespace std; int max_depth = -1; class Tree { private: int info; Tree *left; Tree *right; public: Tree *root; public: Tree(void){root = NULL;} void create_tree(Tree **root1, int info); bool check_if_at_same_level(Tree *root, int depth); private: Tree* get_new_node(int info); }; void Tree::create_tree(Tree **root1, int info) { if((*root1) == NULL) { (*root1) = get_new_node(info); return; } if (info info) create_tree(&((*root1)->left), info); else if(info > (*root1)->info) create_tree(&((*root1)->right), info); } bool Tree::check_if_at_same_level(Tree *root, int depth) { if(root == NULL) return true; if(root->left == NULL && root->right ==NULL)//if it is a leaf { //if max_depth has not been initialized with the leaf-depth. if(max_depth == -1) max_depth = depth; if(depth == max_depth) return true; else return false; } return (check_if_at_same_level(root->left, depth+1) && check_if_at_same_level(root->right, depth+1)); } Tree* Tree::get_new_node(int info) { Tree* newNode = (Tree*)new(nothrow)Tree(); newNode->left = NULL; newNode->right = NULL; newNode->info = info; return newNode; } int main() { Tree tree1; int info; int TREE_SIZE; cout<>TREE_SIZE; for(int i = 0; i < TREE_SIZE; i++) { cout<>info; tree1.create_tree(&tree1.root, info); } if(tree1.check_if_at_same_level(tree1.root,0)) cout<<"nAll leaves are at the same leveln"; else cout<<"nAll leaves are not at the same leveln"; getch(); return 0; } Guest Implementation of the same in C++ (Complete Code) <code class="c++ #include #include #include using namespace std; int max_depth = -1; class Tree { private: int info; Tree *left; Tree *right; public: Tree *root; public: Tree(void){root = NULL;} void create_tree(Tree **root1, int info); void display_inorder(Tree *root); bool check_if_at_same_level(Tree *root, int depth); private: Tree* get_new_node(int info); }; void Tree::create_tree(Tree **root1, int info) { if((*root1) == NULL) { (*root1) = get_new_node(info); return; } if (info info) create_tree(&((*root1)->left), info); else if(info > (*root1)->info) create_tree(&((*root1)->right), info); } void Tree::display_inorder(Tree *root) { if(root == NULL) return; display_inorder(root->left); cout<info<right); } bool Tree::check_if_at_same_level(Tree *root, int depth) { if(root == NULL) return true; if(root->left == NULL && root->right ==NULL)//if it is a leaf { //if max_depth has not been initialized with the leaf-depth. if(max_depth == -1) max_depth = depth; if(depth == max_depth) return true; else return false; } return (check_if_at_same_level(root->left, depth+1) && check_if_at_same_level(root->right, depth+1)); } Tree* Tree::get_new_node(int info) { Tree* newNode = (Tree*)new(nothrow)Tree(); newNode->left = NULL; newNode->right = NULL; newNode->info = info; return newNode; } int main() { Tree tree1; int info; int TREE_SIZE; cout<>TREE_SIZE; for(int i = 0; i < TREE_SIZE; i++) { cout<>info; tree1.create_tree(&tree1.root, info); } //cout<<"n_______________________________nInorder Traversal:n"; //tree1.display_inorder(tree1.root); //cout<<"n_______________________________nn"; if(tree1.check_if_at_same_level(tree1.root,0)) cout<<"nAll leaves are at the same leveln"; else cout<<"nAll leaves are not at the same leveln"; getch(); return 0; } Guest C++ implementation of the same: #include #include #include using namespace std; int max_depth = -1; class Tree { private: int info; Tree *left; Tree *right; public: Tree *root; public: Tree(void){root = NULL;} void create_tree(Tree **root1, int info); void display_inorder(Tree *root); bool check_if_at_same_level(Tree *root, int depth); private: Tree* get_new_node(int info); }; void Tree::create_tree(Tree **root1, int info) { if((*root1) == NULL) { (*root1) = get_new_node(info); return; } if (info info) create_tree(&((*root1)->left), info); else if(info > (*root1)->info) create_tree(&((*root1)->right), info); } void Tree::display_inorder(Tree *root) { if(root == NULL) return; display_inorder(root->left); cout<info<right); } bool Tree::check_if_at_same_level(Tree *root, int depth) { if(root == NULL) return true; if(root->left == NULL && root->right ==NULL)//if it is a leaf { //if max_depth has not been initialized with the leaf-depth. if(max_depth == -1) max_depth = depth; if(depth == max_depth) return true; else return false; } return (check_if_at_same_level(root->left, depth+1) && check_if_at_same_level(root->right, depth+1)); } Tree* Tree::get_new_node(int info) { Tree* newNode = (Tree*)new(nothrow)Tree(); newNode->left = NULL; newNode->right = NULL; newNode->info = info; return newNode; } int main() { Tree tree1; int info; int TREE_SIZE; cout<>TREE_SIZE; for(int i = 0; i < TREE_SIZE; i++) { cout<>info; tree1.create_tree(&tree1.root, info); } //cout<<"n_______________________________nInorder Traversal:n"; //tree1.display_inorder(tree1.root); //cout<<"n_______________________________nn"; if(tree1.check_if_at_same_level(tree1.root,0)) cout<<"nAll leaves are at the same leveln"; else cout<<"nAll leaves are not at the same leveln"; getch(); return 0; } Qualtar Demix Java implementation for the same: int levelOfLeaf = 0; public boolean levelOfLeaves(Node root,int level) { if(root == null){ return true; // True or false. Does not matter. This can never be a leaf node. } if(root.left == null && root.right == null){ // Leaf node. if(levelOfLeaf==0){ levelOfLeaf = level; return true; } else { return levelOfLeaf == level; } } boolean leftLeaf = levelOfLeaves(root.left, level+1); boolean rightLeaf= levelOfLeaves(root.right, level+1); return leftLeaf && rightLeaf; } Subrahmanyan Sankaran #include using namespace std; #define NULL 0 struct Node { int data; Node *left; Node *right; Node *link; Node *parent; int depth; }; class Tree { static int l; static int All_Leaves_at_same_Level; static int leafdepth; static Node * prev; static int count; public: Node *head; int maxdepth; Tree() { prev = NULL; head = NULL; maxdepth = 0; } int GetLevelFlag() { return All_Leaves_at_same_Level; } void InorderSetParent(Node *node, Node *parent) { if(node) { node->parent = parent; InorderSetParent(node->left, node); InorderSetParent(node->right, node); } } void InsertNode(Node *node,int data) { Node * tmp = node; if(head == NULL) { head = new Node; head->data = data; head->left = NULL; head->right = NULL; head->link = NULL; head->parent = NULL; head->depth = 0; return; } else if(tmp) { prev = tmp; if(data > tmp->data) { l=0; tmp = tmp -> right; InsertNode(tmp,data); } else { l=1; InsertNode(tmp->left,data); } } if(l == 1) { prev->left = new Node; prev->left->data = data; prev->left->left = NULL; prev->left->right = NULL; l = -1; return; } else if(l == 0) { prev->right = new Node; prev->right->data = data; prev->right->left = NULL; prev->right->right = NULL; l = -1; return; } } void InorderSetDepth(Node *node) { if(node) { Node *tmp = node; int depth = 0; while(tmp->parent) { depth++; tmp = tmp->parent; } node->depth = depth; InorderSetDepth(node->left); InorderSetDepth(node->right); } } void Check_If_All_Leaves_at_same_Level(Node * node) { if(node) { Check_If_All_Leaves_at_same_Level(node->left); if((node->left == NULL) && (node->right == NULL)) { if( leafdepth == -1) leafdepth = node->depth; if(leafdepth >= 0) { if(leafdepth == node->depth) All_Leaves_at_same_Level = 1; else All_Leaves_at_same_Level = 0; } } Check_If_All_Leaves_at_same_Level(node->right); } } void FindMaxDepth(Node* node) { if(node) { FindMaxDepth(node->left); if(maxdepth depth) maxdepth = node->depth; FindMaxDepth(node->right); } } }; int Tree::l =0; int Tree::leafdepth =-1; int Tree::count = 0; int Tree::All_Leaves_at_same_Level = -1; Node * Tree::prev = NULL; int main(int argc, char* argv[]) { Tree t; t.InsertNode(t.head,10); t.InsertNode(t.head,7); t.InsertNode(t.head,13); t.InsertNode(t.head,5); t.InsertNode(t.head,9); t.InsertNode(t.head,12); t.InsertNode(t.head,15); t.InsertNode(t.head,3); t.InsertNode(t.head,6); t.InsertNode(t.head,8); t.InsertNode(t.head,11); t.InsertNode(t.head,1); t.InsertNode(t.head,4); t.InsertNode(t.head,2); t.InorderSetParent(t.head,NULL); t.InorderSetDepth(t.head); t.Check_If_All_Leaves_at_same_Level(t.head); if(t.GetLevelFlag()) std::cout<<"Leaves are at the same level"<<std::endl; else std::cout<<"Leaves are NOT at the same level"<<std::endl; return 0; } prakash in the second code, it seems like the base case may create problem lets see the below example 12 / 5 / 3 9 / / 1 2 at node 9 –> checkUtil(root->left, level+1) == checkUtil(root->right, level+1); actual_level(not 1) == 1 (right child is null) so false so the function will say that all leaves are not at the same level but leaves are at the same level only. please correct me if i am wrong Vibhu Tiwari No it will print the correct output as the base case is also there to handle it look at it closely when root==NULL return 1. Varun I think Prakash correctly point out the error in second code.. the base case ” if root==NULL then return 1 ” is not handling the case when a node has only one child. for example in the above tree(in Prakash’s Example) just add a right child to node 3 and run second code it’ll give wrong result. because at node 9, call for node 2 will return 4(level+1) while call for empty right sub tree of node 9 will return 1 so at node 9(4!=1) and it will return 0 to node 5 and node 3 will return 1 to node 5 and so on. Vibhu Tiwari Yes you are right. For that i have modified the code. Its the same but now also checks for only one child /* Recursive function which checks whether all leaves are at same level */ int checkUtil(struct Node *root, int level) { // Base case if (root == NULL) return (1); // If a leaf node is encountered if (root->left == NULL && root->right == NULL) return (level+1); // If left child is not null if(root->right==NULL&&root->left!=NULL) return checkUtil(root->left,level+1); // If right child is not null if(root->left==NULL&&root->right!=NULL) return checkUtil(root->right,level+1); return checkUtil(root->left, level+1) & checkUtil(root->right, level+1); } Varun This code still require some changes to work correctly. run this code for 2nd and 3rd example tree in the post, you can find what is wrong with this code. also && operator in last line of code is not a good choice and replacing it with == will introduce new bug. so i think instead of going top down a bottom up approach would be a better choice. Vibhu Tiwari I think there is no need for extra variable for comparison the comparison can be done instead using recursive calls only. typedef struct tree tree_t; struct tree { int data; tree_t *left; tree_t *right; }; tree_t *newNode(int data) { tree_t *n=(tree_t *)malloc(sizeof(tree_t)); n->data=data; n->left=n->right=NULL; return n; } int checkSameLevel(tree_t *n,int level) { if(n==NULL) return 1; if(n->left==NULL&&n->right==NULL) { return level; } return checkSameLevel(n->left,level+1)==checkSameLevel(n->right,level+1); } int main() { tree_t *n=newNode(1); n->left=newNode(2); n->left->left=newNode(3); n->left->left->left=newNode(8); n->left->left->right=newNode(9); printf(” %d “,checkSameLevel(n,0)); } GeeksforGeeks Thanks for suggesting an implementation with only one parameter. We have added it to the original post. Please note that we have used “return level + 1″ for leaf case, otherwise it doesn’t work for a tree with only one node. hary I have a doubt, is the code above really working in all cases, for e.g. consider a Tree on 3 nodes : 15 is the root and 15->left = 12, 15->right = NULL, 12->left = NULL, 12->right = 2, 2->left = NULL, 2->right = NULL Ideally only one leaf is there and the result should be true. Correct me If I have traced it incorrectly. Above everything, I believe the previous solution was more elegant as it kept things simple without comprising on time of execution. The current solution is ambiguous – it returns a bool indicating the output of the function and at the same time returns the level of a leaf as well. In my opinion we should have the previous solution regardless of the fact that the current one is correct or not. Abhishek Anand One more approach may a level order traversal using queue. hary Hmm, not sure what do you mean by this, because the statement seems a bit incomplete, so if you can explain the approach we can discuss more on this, I definitely see a solution here – though not as efficient as the one quoted above. Abhishek Anand Hi hary, Below is my solution: #include #include // A binary tree node template struct node { itemType data; node *_left; node *_right; }; // A utility function to allocate a new tree node template node* newNode(itemType data) { node* tempNode = new node ; tempNode->data = data; tempNode->_left = NULL; tempNode->_right = NULL; return tempNode; } template bool areLeavesAtSameLevel(node* &root) { //If tree is empty consider it as same level. if(root == NULL) return true; bool leafNodeFound = false; std::queue <node*> myQue; myQue.push(root); //Extra node as end marker. myQue.push(NULL); while(!myQue.empty()) { root = myQue.front(); myQue.pop(); if(root) { if(root->_left == NULL && root->_right == NULL) leafNodeFound = true; } //Done with current level. if(root == NULL) { if(leafNodeFound && !myQue.empty()) return false; if(!myQue.empty()) myQue.push(root); } else { if(root->_left) myQue.push(root->_left); if(root->_right) myQue.push(root->_right); } } return true; } int main() { node *root = newNode(12); root->_left = newNode(5); root->_left->_left = newNode(3); root->_left->_right = newNode(9); root->_left->_left->_left = newNode(1); root->_left->_right->_left = newNode(1); std::cout << (areLeavesAtSameLevel(root) ? "Leaves are at same level" : "Leaves are not at same level") << std::endl; return 0; } hary My apologies for being late – in fact very late in answering response to your query. I appreciate you writing the complete code here. My only cent here is the approach is simple – though not efficient – I would also say I have not verified this, so please correct me If I am wrong here: Step1: Iterate over the tree and count the no of leaves in the tree O(n) Step2 : Perform level order traversal and check that the no of nodes in the last level shall be same as count computed in step1. O(n) (I have assumed that the level order traversal in it’s last phase always processes the leaves only) hary I see by the time I wrote the comment the recursive calls were there :), anyways code looks good now. hary I think you have missed the main recursive calls, that will complete the traversal. Correct me If I have interpreted incorrectly. Harshada Patil int check(tNode *temp){ int count1 = 0, count2 = 0; if(temp->left == NULL){ if(temp->right == NULL) return 0; count1 = check(temp->right); if(count1 == -1) return -1; return count1 + 1; } if(temp->right == NULL){ count2 = check(temp->left); if(count2 == -1) return -1; return count2 + 1; } count1 = check(temp->left); count2 = check(temp->right); if((count1 == -1) || (count2 == -1)) return -1; if(count1 == count2) return count1 + 1; else return -1; } Guest . Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
