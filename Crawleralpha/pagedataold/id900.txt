Move all zeroes to end of array - GeeksforGeeks GeeksforGeeks A computer science portal for geeks GeeksQuiz Login Home Algorithms DS GATE Interview Corner Q&A C C++ Java Books Contribute Ask a Q About Array Bit Magic C/C++ Articles GFacts Linked List MCQ Misc Output String Tree Graph Move all zeroes to end of array Given an array of random numbers, Push all the zero’s of a given array to the end of the array. For example, if the given arrays is {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0}, it should be changed to {1, 9, 8, 4, 2, 7, 6, 0, 0, 0, 0}. The order of all other elements should be same. Expected time complexity is O(n) and extra space is O(1). There can be many ways to solve this problem. Following is a simple and interesting way to solve this problem. Traverse the given array ‘arr’ from left to right. While traversing, maintain count of non-zero elements in array. Let the count be ‘count’. For every non-zero element arr[i], put the element at ‘arr[count]’ and increment ‘count’. After complete traversal, all non-zero elements have already been shifted to front end and ‘count’ is set as index of first 0. Now all we need to do is that run a loop which makes all elements zero from ‘count’ till end of the array. Below is C++ implementation of the above approach. 
// A C++ program to move all zeroes at the end of array
#include <iostream>
using namespace std;

// Function which pushes all zeros to end of an array.
void pushZerosToEnd(int arr[], int n)
{
    int count = 0;  // Count of non-zero elements

    // Traverse the array. If element encountered is non-zero, then
    // replace the element at index 'count' with this element
    for (int i = 0; i < n; i++)
        if (arr[i] != 0)
            arr[count++] = arr[i]; // here count is incremented

    // Now all non-zero elements have been shifted to front and 'count' is
    // set as index of first 0. Make all elements 0 from count to end.
    while (count < n)
        arr[count++] = 0;
}

// Driver program to test above function
int main()
{
    int arr[] = {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9};
    int n = sizeof(arr) / sizeof(arr[0]);
    pushZerosToEnd(arr, n);
    cout << "Array after pushing all zeros to end of array :\n";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    return 0;
}
 Output: Array after pushing all zeros to end of array :
1 9 8 4 2 7 6 9 0 0 0 0 Time Complexity: O(n) where n is number of elements in input array. Auxiliary Space: O(1) This article is contributed by Chandra Prakash. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.           Related Topics: K’th Smallest/Largest Element in Unsorted Array | Set 2 (Expected Linear Time) K’th Smallest/Largest Element in Unsorted Array | Set 1 Time complexity of insertion sort when there are O(n) inversions? How to check if two given sets are disjoint? Minimum Number of Platforms Required for a Railway/Bus Station Find the closest pair from two sorted arrays Print all elements in sorted order from row and column wise sorted matrix Length of the largest subarray with contiguous elements | Set 1 Tweet Writing code in comment? Please use ideone.com and share the link here. abc #include using namespace std; #define swap(a,b,c) {c=a;a=b;b=c;} int main() { int a[]={1,0,5,0,6,3,0,4,7,0}; int len=sizeof(a)/sizeof(a[0]); int low=0,high=len-1; int i=0,temp=0; while(low<high) { if(a[high]==0) { high–; } if(a[low]==0&&a[high]!=0) { cout<<low<<" "<<high<<endl; swap(a[low],a[high],temp); low++; high–; } low++; } for(i=0;i<len;i++) cout<<a[i]<<" "; system("pause"); } http://justhackitnow.com sumit gaur Your code’s complexity will be O(n+cn) as upto some extend you are traversing twice …. here’s with O(n) traverse only once void rearrange(int a[],int size) { int end=0; for(int i=0;i<size;i++) { if(a[i]) { int tmp=a[end]; a[end]=a[i]; a[i]=tmp; end++; } } } Guest Your code’s complexity will be O(n+cn) as upto some extend you are traversing twice …. here’s with O(n) traverse only once void rearrange(int a[],int size) { int end=0; for(int i=0;i<size;i++) { if(a[i]) { int tmp=a[end]; a[end]=a[i]; a[i]=tmp; end++; } } } Guest Your code’s complexity will be O(n+cn) as upto some extend you are traversing twice …. here’s with O(n) traverse only once void rearrange(int a[],int size) { int end=0; for(int i=0;i<size;i++) { if(a[i]) { int tmp=a[end]; a[end]=a[i]; a[i]=tmp; end++; } } } Ramesh private void move(int[] arr) { int countZeroes = 0; for(int i=0; i < arr.length; i++) { if(arr[i] == 0) { countZeroes++; } else { if(countZeroes != 0) { arr[i-countZeroes] = arr[i]; arr[i] = 0; } } } } swap public class MoveZerosToEnd { public static void main(String… args) { MoveZerosToEnd m = new MoveZerosToEnd(); System.out.println(Arrays.toString(m.moveZero(new int[]{0, 1, 2, 3, 0, 9, 4}))); } public int[] moveZero(int[] arr) { int k = 1; int i = 0; while (i < arr.length) { if (arr[i] == 0) { for (int j = i + 1; j < arr.length; j++) { if (j == arr.length) return arr; if (arr[j] != 0) { arr[i] = arr[j]; arr[j] = 0; break; } } } i++; } return arr; } } Nodirbek How about my algorithm: For each element of array from right to left check if it’s zero then swap it with last non-zero element. We keep track of last non-zero element, and shift to left as we swap. Since the problem statement says just push zeros to the end (not actually shifting non-zero numbers to left) this is correct solution. Below code explains better: http://ideone.com/12oEWe rr import java.util.Arrays; class test { public static void main(String[] args) { int[] x = {0,1,2,3}; int count = 0; if(x == null){ return; } for(int i = 0; i<x.length; i++){ if(x[i] != 0){ x[count] = x[i]; count++; } } for(int j = count; j<x.length;j++){ x[j] = 0; } System.out.println(Arrays.toString(x)); } } ravi jadhav Here is a simple fact to exploit. Multiplying zero with any element produces a zero. So rather than comparing each element, just keep looking whether the multiplication of successive pairs is zero. If it is zero, you have to check whether both the element are zeroes. You can use subtraction to check if both are zero. If one of them is zero, find out which is zero by comparing. Here is the java code i wrote. I believe when the number of zeroes are lesser compared to array length, it does lesser number of comparison. On average n/2. http://ideone.com/IIYYsr Rahul Ramesh But multiplying causes overhead right???? I am not very sure…. rihansh this can also be done by selecting 0 as pivot element as in case of quick sort but this will not work in cse of negative elements rihansh BUT THIS WILL TAKE TWO PASSES WHEN ALL ELEMENT IN THE ARRAY ARE APPROXIMATELY ZERO I HAVE AN BETTER OPTION START iterating from right side kept one pointer at end and other one is iteraing whenever we encountered a zeroth element we replace it with the pointer position and decrementing hope u get me other i will post a code rj @rihansh but in this case, order of non-zero elements will not retain bikash I think we can approach this problem by keeping two pointers indicating the current zero and non-zero element position, and swapping them. This continues till all zeros are moved to the end. Take a look here: http://ideone.com/UMHryG Jonathan It could run O(n^2) time. (depends on input) Suppose we have: 00000011111111111111111111111111111111111111111111 Starting from the back, ‘end’ will increment one each while loop iteration, yet have to nearly traverse the majority of the array each iteration to find the next zero to swap with. Assad Safiullah That way the order won’t be maintained, which is a requirement here. Mona This method uses the partition step of the Quicksort algo … Proved sol in O(n). #include using namespace std; void pushZerosToEnd(int arr[],int n) { int i=-1; for(int j=0;j<n;j++) { if(arr[j]!=0) { i++; arr[i]=arr[j]; } else continue; } for(int j=i+1;j<n;j++) arr[j]=0; } int main() { int arr[] = {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9}; int n = sizeof(arr) / sizeof(arr[0]); pushZerosToEnd(arr, n); cout << "Array after pushing all zeros to end of array :n"; for (int i = 0; i < n; i++) cout << arr[i] << " "; return 0; } trojansmith Hi,,this partitions the array into non zero and zero int[] arr = {1,9,8,4,0,0,2,7,0,6,0}; int temp=0; int i=0,j=0; //reach first zero while(arr[i]!=0)i++; j=i; //partition array into 0 and non-zero while(i<arr.length && j<arr.length){ if(arr[i]!=0){ //swap temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; j++; } i++; } trojansmith trojansmith…hi this i have given will partition the array into non zero and zeroes int[] arr = {1,9,8,4,0,0,2,7,0,6,0}; int temp=0; int i=0,j=0; //reach first zero while(arr[i]!=0)i++; j=i; //partition array into 0 and non-zero while(i<arr.length && j<arr.length){ if(arr[i]!=0){ //swap temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; j++; } i++; } xyz int i=0,j=0; while(j!=length) { if(array[j]!=0) { int temp=array[j]; array[j]=0; array[i]=temp; i++; j++; } else { j++; } } Guest #include int main(){ int n; scanf(“%d”,&n); int i,arr[n]; for(i=0;i<n;i++) scanf("%d",&arr[i]); int j=0; i=0; while(i<n && j<n){ while(arr[i] && i<n) i++; if(i<n){ j = i+1; while(!arr[j] && j=n) break; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; i++; j++; } else break; } for(i=0;i<n;i++) printf("%d ",arr[i]); return 0; } Sheetal Garg #include int main() { int flag=0,temp,i,j,arr[10]={1,0,9,8,0,0,6,2,0,1}; i=0;j=i+1; while(j<10) { if(arr[i]!=0&&flag==0) { i++; j++; } else { flag=1; } if(flag==1) { if(arr[j]!=0) { temp=arr[j]; arr[j]=arr[i]; arr[i]=temp; i++; } j++; } } } Pradeep Patel Performance can be improved if self replacement can be avoided. In case there are no 0s no copying will be done. for (int i = 0; i < n; i++) if (arr[i] != 0) { if(count != i) //avoid self replacement arr[count] = arr[i]; // here count is incremented ++count; } krrish You can not bet it to be improvement as perhaps conditional evaluation take almost same time as of assignment(depends on processor).Also you are performing n conditionals + some assignments…….. Harish Kumar “Correct me if i m wrong” Well we can do it by two pointers and we traverse the whole array only once and making just the required number of writes Take two pointers i=0 and j=0 do these steps until j is less than length –> assign ‘i’ the first zeroth index from left –>assign ‘j’ the first non Zeroth index from left after ‘i’ (greater than i) –> Swap the values at those indices Pushkar Worst Case your algo might take O(n2) Guest “Correct me if i m wrong” Well we can do it by two pointers and we traverse the whole array only once and making just the required number of writes Take two pointers i=0 and j=0 do these steps until j assign ‘i’ the first zeroth index from left –>assign ‘j’ the first non Zeroth index from left after ‘i’ (greater than i) –> Swap the values at those indices The code in c is as follows void shiftZeros(int array[],int n) { int i=0,j=0; i = getNextZeroIndex(i,n,array); if( i == -1) return; j = i+1; while(j<n) { if(array[j]) { array[i] = array[j]; array[j] = 0; i++; i = getNextZeroIndex(i,n,array); if(i == -1) return; j = i; } j++; } printArray(array,n); } int getNextZeroIndex(int i,int n,int array[]) { while(i<n && array[i] != 0) { if( i == n) return -1; i++; } return i; } Pravin Please forgive my ignorance.. wats the programming language that is being used here ? http://himanshu1.wordpress.com/ Himanshu Mishra My in python. Surprisingly same Algorithm import time def main(): start = time.time() a = [1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0] b = [] count = 0 for i in a: if i != 0:b.append(i) else:count += 1 c = [0] * count answer = b + c print(answer) print("time taken : ",time.time() -start) return 0 if __name__ == '__main__': main() Dinesh Panchananam # Pyth 2.7 Shorter code. f= [1,9,8,4,0,0,2,7,0,6,0,23,32] g = filter(lambda x:x!=0 ,f) print g+(len(f)-len(g))*[0] sathish I tried a Simple one.If anything wrong ,please advice.The code is working 100%. no extra space used. void movee(int *a,int n) { int i,c=n-1; for(i=0;ii) { if(*(a+c)!=0) break; c–; } } if(i>c) break; if(*(a+i)==0) { swapp((a+i),(a+c)); c–; } } } OUTPUT: 1 0 0 9 -1 3 0 0 66 0 0 4 -1 6 1 0 0 0 0 1 1 6 9 -1 3 -1 4 66 0 0 0 0 0 0 0 0 0 0 shashi dude, maintain order Ruhi Sharma We can also do this by taking two variables i and j, initialize i as index 0 and j as index ‘n-1′. Now, keep incrementing i till we find a 0 and then keep decrementing j till we find a non-zero and swap both of them. Continue this until i >= j C code for the above approach is : front_index=0; end_index=no_of_elem-1; while(front_index < end_index) { if(arr[front_index]==0) { if(arr[end_index]!=0){ arr[front_index]= arr[end_index]; arr[end_index]=0; front_index++; end_index–; } else{ end_index–; } } else{ front_index++; } } guest The order of non-zero elements are not preserved by this method. abhisek we cannot use dutch flag here as the order has to be maintained http://atiqwhiz.blogspot.in/ atiq @GeeksforGeeks ….Good exploitation but No need to do this part….. // Now all non-zero elements have been shifted to front and ‘count’ is // set as index of first 0. Make all elements 0 from count to end. while (count < n) arr[count++] = 0 just do replace a[i] with 0 at the same moment for (int i = 0; i < n; i++) if (arr[i] != 0) { arr[count++] = arr[i]; arr[i]=0; } That's how in one pass…. ssd this will not work. try it on the array with one element [1] rk We can set arr[i]=0 only when (i != count-1) . Is there any other case? pavansrinivas Code in JAVA (similar to partition in Quicksort)… void arrange(){ int[]a = {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0}; int l = 0; int r = a.length-1; while(l<r){ while(a[l]!=0&&ll){ r--; } a[l] = a[r]; a[r] = 0; l++; r--; } for(int i=0;i<a.length;i++){ System.out.print(a[i]+" "); } } Rashik #define N 15 void main() { int ar[N]={0,0,20,30,0,0,0,40,0,0,50,0,60,0}; int j=0,i=0; while(1) { while(ar[i]!=0) i++; j=i ; while(ar[i]==0) { i++; if(i==N) goto l; } ar[j]=ar[i]; ar[i]=0; i=j; } l: for(int i=0;i<N;i++) printf("%d ",ar[i]); } Satyendra Kumar Singh void ShiftZeroToEnd(int arr[],int n) { int cur=-1; for(int i=0;i<n;i++) { if(arr[i]==0) { if(cur==-1) cur=i; } else if(cur!=-1) { arr[cur]=arr[i]; arr[i]=0; cur++; } } } The above program will push all zeros in one pass.. sijayaraman void move_zero_to_end(int arr[],int len) { int j = -1; for(int i=0;i<len;i++) { if(arr[i]!=0 ) { j++; swap(&arr[i],&arr[j]); } } void swap(int *a,int *b) { int t=*a; *a=*b; *b=t; } guest #include using namespace std; int main() { int a[]={1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9}; int n=sizeof(a)/sizeof(a[0]); int m=n,k; for(int i=0;i<n;i++) { if(a[i]==0) for(int j=i+1;j<n;j++) if(a[j]!=0) { k=a[i]; a[i]=a[j]; a[j]=k; break; } } for(int i=0;i<n;i++) cout<<a[i]<<" "; } Guest #include using namespace std; int main() { while (1) { int array[30]; int arraySize; cin >> arraySize; for (int i = 0; i > array[i]; } int writePtr = 0; int temp; for (int readPtr = 0; readPtr < arraySize; readPtr++) { temp = array[readPtr]; if (temp != 0) { array[writePtr] = temp; writePtr++; } } while (writePtr < arraySize) { array[writePtr] = 0; writePtr++; } for (int i = 0; i < arraySize; i++) { cout << array[i] << " "; } } return 0; } REYAZ another simpe method is to maintain two indices i and j, traverse the array till we find the first 0, then make i and j point to this element and then we increment j till the end of the array while doing the following: if element pointed to by j is 0 then j++, else if element pointed to by j is other than 0 , then swap the elements of position i and j , and then increment both i and j. COMPLEXITY: O(n). this is a modified version of DNF algo, in which while segregating three types, we get at least one type of objects with their order preserved.. plz correct me if i am wrong Yash Girdhar OR you can also start i as index 0 and j as index ‘n-1′. Now, keep incrementing i till we find a 0 and then keep decrementing j till we find a non-zero and swap both of them. continue till i>j. Jekin Yes. But then it won’t preserve original order. Yash Girdhar oh ! Yes ! Thanks for pointing that out Hector I think this is correct!!!! Vijay Kumar int i = 0; for( i=0; i<n; i++){ if(a[i]==0){break;} } for(int j=0; j<n; j++){ if(a[j]!=0){ swap(a,i,j); i++; } } rohit start 2 pointers (one from start and other from next to it) , keep looking for 0 in start pointer and non-zero in 2nd pointer and swap elements accordingly. Raunak Singh We could also do this by keeping a count of the number of zero elements. http://pastebin.com/ne0M60zM Sorry, I had to use pastebin as I was unable to format my code here.. deepak The quicksort partition would work with pivot as 0 if there are no negative numbers. Aman Using the idea of quicksort we can shift all non zero elements on one side ‘but’ we may loose the ordering of elements. Jerry no, ordering of elements wont be lost in this case… trace it and u’ll get to know Saurabh Jerry, it looks like with Quick sort, we will loose the ordering. Here is an example: Array Before QuickSort [1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0] —— 1. Initialize all variables pivot = 0; i = 0; j = 10 (array length -1) —– 2. Continue until i pivot. Stop at the first instance when array[i] <= pivot 2.2 decrement j until array[j] pivot 2.3 swap array[i] and array[j] —– first swap [1, 9, 8, 4, 6, 0, 2, 7, 0, 0, 0] second swap [1, 9, 8, 4, 6, 7, 2, 0, 0, 0, 0] we lost the positions for 6 and 7. Jerry Well, I’m not too sure about the validity of your algorithm. Did you figure it out by yourself or did you find it from a book? If you figured it out, then Hi5, I love you passion. But unfortunately according to the so called bible of algorithms, i.e, Cormen third edition: The following code partitions A[p..r] around A[r] Partition(A, p,r) 1: x ? A[r] (x is “pivot” and is 0 in this case) 2: i ? p ? 1 3: for j ? p to r ? 1 do 4: if A[j] > x then 5: i ? i + 1 6: swap A[i] and A[j] 7: end if 8: end for 9: swap A[i + 1] and A[r] 10: return i + 1 When this algorithm is executed on the set [1,9,8,4,0,0,2,7,0,6,0], the following sequences emerge: first execution of ‘if’ condition: 19840027060 second execution of ‘if’ condition:19840027060 third: 19840027060 fourth: 19840027060 fifth: 19842007060 sixth: 19842700060 seventh: 19842760000 END Time complexity is O(n) ssd What about the case when the last element is not zero? What will be the pivot in that scenario? deepak Thanks to point out. Meraj Ahmed We could use two pointers, one left->right (let it be P1) and other right->left (let it be P2). We keep incrementing P1 unless we find a 0 then we decrement P2 unless we find a non-zero value, we then swap them. We keep doing the above process until P1<=P2. Pushkar Swapping will not keep the non-zero elements in the same order… Take a closer look at the given example.. Anirudh Kumar Yes absolutely. I had a similar algorithm in mind. Your approach would fulfil the requirement of O(n) time complexity and O(1) space complexity. The solution in the above article however has a space complexity of O(n) and not O(1). Anirudh Kumar Oops I am sorry. The solution in the article is right and has a space complexity of O(1). I kind of over looked it. REYAZ the order wont be maintained i think, instead we can have both pointers moving from left to right from appropriate positions…see my method above for a better explanation Guest good question Ankit Jain import java.util.ArrayList; public class Test { public static void main(String[] args){ int[] arr = {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0}; ArrayList arr1 = new ArrayList(); int count = 0; for(int i=0;i<arr.length;i++){ if(arr[i] != 0){ arr1.add(arr[i]); } else{ count++; } } for(int i=0;i<count;i++){ arr1.add(0); } System.out.println(arr1); } } Ankit Jain I don’t know why the format is not coming in readable mode. KD why we set elements to ZERO from ‘count’ to ‘n’ as all the elements after count is already ZERO ? Saurabh It may not be the case always, in the example array {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0}, when the movements of non zero elements is done the resulting array will be {1, 9, 8, 4, 2, 7, 6, 0, 0, 6, 0}. Note, the value 6 in the second last position. That is 6th original location. This needs to be wiped out with 0. So overwriting array from count to n with zeros is required at the end. DurgaPrasad10 import java.util.Arrays; public class MoveZro { public static int[] moveZeroEnd(int[] inputArray){ int len = inputArray.length; int[] outputArray = new int[len]; int count=0; for(int i=0;i<inputArray.length;i++){ int temp=inputArray[i]; if(temp!=0){ outputArray[count++]=temp; } } for(;count<len-1;count++){ outputArray[count]=0; } return outputArray; } public static void main(String[] args) { int[]iArray = {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0}; System.out.println(Arrays.toString(moveZeroEnd(iArray))); } } Guest Another way traverse tha array from L->R and keep counting the number of o’s by incrementing the variable p for every 0 , and store all non 0 values in temp[array]. Then add 0 equal to p in temp[array]. Code10 i Guess space complexity is O(1) naini the space complexity for this is O(N) Interview Experiences Advanced Data Structures Dynamic Programming Greedy Algorithms Backtracking Pattern Searching Divide & Conquer Mathematical Algorithms Recursion Geometric Algorithms Popular Posts All permutations of a given string Memory Layout of C Programs Understanding “extern” keyword in C Median of two sorted arrays Tree traversal without recursion and without stack! Structure Member Alignment, Padding and Data Packing Intersection point of two Linked Lists Lowest Common Ancestor in a BST. Check if a binary tree is BST or not Sorted Linked List to Balanced BST Follow @GeeksforGeeks Subscribe Recent Comments @geeksforgeeks, Some rights reserved        Contact Us! Powered by WordPress & MooTools, customized by geeksforgeeks team
